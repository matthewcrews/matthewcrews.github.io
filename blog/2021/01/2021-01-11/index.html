<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Minimizing Waste for the Cutting Stock Problem | Matthew Crews</title>

<meta name="keywords" content="" />
<meta name="description" content="I was recently posed the question, &ldquo;Can you use Mathematical Planning to optimize the Cutting Stock problem?&rdquo; For those who are not familiar with this problem, you can find the Wikipedia article here. In summary, you have a stock size of paper material from which you need to produce smaller sizes. In the example provided on Wikipedia, the stock size is 5600mm. You are asked to produce a variety of sizes between 1380mm and 2200mm.">
<meta name="author" content="">
<link rel="canonical" href="https://matthewcrews.com/blog/2021/01/2021-01-11/" />
<link href="/assets/css/stylesheet.min.d5d820de85dae34a78c22303e07aa685bb90ec25a056c702c0b1a964ca68861d.css" integrity="sha256-1dgg3oXa40p4wiMD4HqmhbuQ7CWgVscCwLGpZMpohh0=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://matthewcrews.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://matthewcrews.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://matthewcrews.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://matthewcrews.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://matthewcrews.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.78.2" />


<meta property="og:title" content="Minimizing Waste for the Cutting Stock Problem" />
<meta property="og:description" content="I was recently posed the question, &ldquo;Can you use Mathematical Planning to optimize the Cutting Stock problem?&rdquo; For those who are not familiar with this problem, you can find the Wikipedia article here. In summary, you have a stock size of paper material from which you need to produce smaller sizes. In the example provided on Wikipedia, the stock size is 5600mm. You are asked to produce a variety of sizes between 1380mm and 2200mm." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://matthewcrews.com/blog/2021/01/2021-01-11/" />
<meta property="article:published_time" content="2021-01-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-01-11T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Minimizing Waste for the Cutting Stock Problem"/>
<meta name="twitter:description" content="I was recently posed the question, &ldquo;Can you use Mathematical Planning to optimize the Cutting Stock problem?&rdquo; For those who are not familiar with this problem, you can find the Wikipedia article here. In summary, you have a stock size of paper material from which you need to produce smaller sizes. In the example provided on Wikipedia, the stock size is 5600mm. You are asked to produce a variety of sizes between 1380mm and 2200mm."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Minimizing Waste for the Cutting Stock Problem",
  "name": "Minimizing Waste for the Cutting Stock Problem",
  "description": "I was recently posed the question, \u0026amp;ldquo;Can you use Mathematical Planning to optimize the Cutting Stock problem?\u0026amp;rdquo; For those who are not familiar with this problem, you can …",
  "keywords": [
    
  ],
  "articleBody": "I was recently posed the question, “Can you use Mathematical Planning to optimize the Cutting Stock problem?” For those who are not familiar with this problem, you can find the Wikipedia article here. In summary, you have a stock size of paper material from which you need to produce smaller sizes. In the example provided on Wikipedia, the stock size is 5600mm. You are asked to produce a variety of sizes between 1380mm and 2200mm. The ideal plan is one which minimizes the amount of waste. This is a classic planning problem that can actually be reduced to the knapsack problem.\n Note: Full code for this post can be found here\n These are the cut lengths and quantities you need to produce in the example problem.\n   Width [mm] Number of Items     1380 22   1520 25   1560 12   1710 14   1820 18   1880 18   1930 20   2000 10   2050 12   2100 14   2140 16   2150 18   2200 20    There are a variety of different ways you can cut the stock size into the smaller sizes. For example, you could produce 3 x 1820mm cuts from a 5600mm stock roll. You could also do 2200mm, 1820mm, and 1560mm. In total there are 308 possible combinations of cuts, not including the empty combination which has zero cuts. The most important thing to realize when approaching this problem is that the order you make the cuts does not matter. A more technical term would be that the order of cuts is commutative.\nGenerating the Possible Cuts The most difficult part of this problem turned out to be the generating of the possible cuts. Before we dive right into that though, let’s create some simple domain types to describe our problem.\ntype Cut = Cut of float type Plan = Plan of MapCut, int A Cut is a length we want to create from our stock rolls. A Plan is a set of cuts. We want an algorithm which will generate the possible Plans for a set of Cuts for our stock roll. To make our lives easier, I am going to go ahead and write some functions which allow us to work with these types more easily.\nmodule Cut = /// Take a Cut and return the length as a float  let length (Cut length) = length module Plan = /// Give me a Plan with no cuts  let empty : Plan = Plan Map.empty /// Give me the total length of cuts in the plan  let length (Plan plan) = plan | Seq.sumBy (fun (KeyValue(Cut cut, count)) - cut * float count) /// Add a Cut to a Plan and return a new Plan  let addCut (cut: Cut) (Plan plan) = match Map.tryFind cut plan with | Some count - Plan (Map.add cut (count + 1) plan) | None - Plan (Map.add cut 1 plan) /// Give me the count of each distinct cut in a given Plan  let cutCounts (Plan plan) = plan | Seq.map (fun (KeyValue(cut, count)) - cut, count) We now have our domain for working in this space. Let’s talk about the function which will generate the possible Plans given a set of Cuts and a Stock Length. We want something like this:\nlet generatePlans (stockLength: float) (cuts: Cut list) : Plan list = // Do some magic here?? Now, I’m going to show you the answer that I came up with. What you are not seeing though is the couple of hours I spent with my notebook sketching out how this would work. It was not intuitive to me, so I don’t want you to think that this stuff just materializes out of thin air. I had to struggle. It was not intuitive but by the time I was done, I felt immense satisfaction.\nThe first thing I am going to do is sort cuts from the shortest length to the longest and ensure that I only have distinct cuts.\nlet sortedCuts = cuts | List.distinct | List.sortBy (fun (Cut length) - length) This algorithm is going to take advantage of the fact that the cuts are sorted from shortest to longest so that it can terminate early. Now I want to write a recursive function which is going to take an initially empty Plan and try adding cuts to it. It will keep adding cuts until it exceeds the Stock Length. You can think of this as a sort of Constructive Heuristic. I’m going to show you the full function but then we will unpack it.\nlet rec generate (candidates: (Plan * Cut list) list) (approved: Plan list) = match candidates with | [] - approved | testCandidate::remainingCandidates - let plan, cuts = testCandidate match cuts with | [] - let newApproved = plan::approved generate remainingCandidates newApproved | nextCut::remainingCuts - if Plan.length plan + Cut.length nextCut  stockLength then let newPlan = Plan.addCut nextCut plan let newCandidates = (newPlan, cuts)::(plan, remainingCuts)::remainingCandidates generate newCandidates approved else let newApproved = plan::approved generate remainingCandidates newApproved We have a list of plans and possible cuts which we are exploring called candidates. As candidates are approved, they are added to the approved list of plans. Keep in mind, this function will be initially called with an empty Plan and the full list of Cuts available. Let’s go through the cases step by step.\nmatch candidates with | [] - approved This is the terminal case. We have evaluated all the Plans that were generated, and we return the Plans in the approved list. Now for the case where we still have remaining candidates.\n| testCandidate::remainingCandidates - let plan, cuts = testCandidate In this case, there is at least one remaining candidate to evaluate, testCandidate. We create plan and cuts values using structural unpacking of testCandidate. plan is the Plan we are testing. cuts is the list of possible cuts we can add to plan. You will see that this list will shrink as our algorithm continues.\nNow let’s match against the list of Cuts to see what we should do.\nmatch cuts with | [] - let newApproved = plan::approved generate remainingCandidates newApproved If the list of cuts is empty, as indicated by the [] case, then we create newApproved by adding plan to approved and calling generate again. Now let’s look at the case where there are Cuts remaining.\n| nextCut::remainingCuts - if Plan.length plan + Cut.length nextCut  stockLength then let newPlan = Plan.addCut nextCut plan let newCandidates = (newPlan, cuts)::(plan, remainingCuts)::remainingCandidates generate newCandidates approved else let newApproved = plan::approved generate remainingCandidates newApproved We now look at nextCut which we know is the shortest of the Cuts in the list due to our sorting. We check that if we add this Cut to plan whether we will exceed the stockLength limit. If we do not exceed the limit, we create a new plan newPlan. We will add newPlan to the list of candidates with cuts as the list of possible Cuts to explore. We also add the current Plan we are testing, plan, to the list of candidates but now with remainingCuts as the possible Cuts to add. Take your time with that. That puzzle took me awhile to figure out.\nIn the case that the length of nextCut is too long, we add plan to approved and then continue to search the remaining candidates.\nWe call our recursive function with an empty Plan to start and the full list of Cuts to get all the possible Plans we would want to consider.\nlet initialCandidate = Plan.empty, sortedCuts generate [initialCandidate] [] The Optimization Problem The optimization model for this is rather simple. We will create the list of possible Plans using the function we just described. We will associate an integer Decision with each Plan which is to indicate how many of each of those plans we will schedule. Let’s setup the data for our model so that we can build it. All this data is taken from the Wikipedia example.\nlet cuts = [ 1380.0 1520.0 1560.0 1710.0 1820.0 1880.0 1930.0 2000.0 2050.0 2100.0 2140.0 2150.0 2200.0 ] | List.map Cut let cutRequirements = [ Cut 1380.0 , 22.0 Cut 1520.0 , 25.0 Cut 1560.0 , 12.0 Cut 1710.0 , 14.0 Cut 1820.0 , 18.0 Cut 1880.0 , 18.0 Cut 1930.0 , 20.0 Cut 2000.0 , 10.0 Cut 2050.0 , 12.0 Cut 2100.0 , 14.0 Cut 2140.0 , 16.0 Cut 2150.0 , 18.0 Cut 2200.0 , 20.0 ] | Map let stockLength = 5600.0 let plans = generatePlans stockLength cuts We now want to start building our model. We’ll open the namespaces we need and create our set of Decisions associated with each Plan in plans. We are using SliceMaps to simplify formulation.\nopen Flips open Flips.Types open Flips.SliceMap let planDecs = DecisionBuilder \"PlanCount\" { for plan in plans - Integer (0.0, infinity) } | SMap We then need to calculate the number of each Cut that is associated with each Plan. This will be important for us to formulate the constraints around meeting the minimum cut requirements. We will store this information in a 2-D SliceMap where the first index is the Plan and the second index is the Cut. The value in the SliceMap is the number of a given Cut in the Plan.\nlet planCutCounts = plans | Seq.collect (fun plan - Plan.cutCounts plan | Seq.map (fun (cut, count) - (plan, cut), float count) ) | SMap2 It’s now actually simple to create our constraints. We will create a constraint for each Cut in our data stating that the solution must meet the minimum quantity of each Cut.\nlet cutRequirementConstraints = ConstraintBuilder \"CutRequirements\" { for cut in cuts - sum (planDecs .* planCutCounts.[All, cut]) == cutRequirements.[cut] } Our objective is to minimize the total number of stock rolls required to meet the demand for each Cut.\nlet objective = Objective.create \"MinRolls\" Minimize (sum planDecs) We combine these into our model and solve.\nlet model = Model.create objective | Model.addConstraints cutRequirementConstraints let result = Solver.solve Settings.basic model Let’s go ahead and provide some nice printing of the results to the console.\nmatch result with | Optimal solution - let values = Solution.getValues solution planDecs | Map.filter (fun _ quantity - quantity  0.0) let totalNumberOfRolls = values | Seq.sumBy (fun (KeyValue(_, count)) - count) printfn \"Quantity | Plan\" for KeyValue(plan, quantity) in values do printfn $\"%8.0f{quantity} | {plan}\" printfn \"==========================================\" printfn $\"Total Number of Rolls: {totalNumberOfRolls}\" printfn \"==========================================\" | _ - failwith \"Unable to solve\" When you run the full script, you will see the following printed out.\nQuantity | Plan\r8 | Plan (map [(Cut 1380.0, 1); (Cut 2000.0, 1); (Cut 2200.0, 1)])\r7 | Plan (map [(Cut 1380.0, 1); (Cut 2050.0, 1); (Cut 2150.0, 1)])\r7 | Plan (map [(Cut 1380.0, 1); (Cut 2100.0, 2)])\r10 | Plan (map [(Cut 1520.0, 1); (Cut 1880.0, 1); (Cut 2200.0, 1)])\r10 | Plan (map [(Cut 1520.0, 1); (Cut 1930.0, 1); (Cut 2140.0, 1)])\r3 | Plan (map [(Cut 1520.0, 1); (Cut 1930.0, 1); (Cut 2150.0, 1)])\r2 | Plan (map [(Cut 1520.0, 1); (Cut 2000.0, 1); (Cut 2050.0, 1)])\r2 | Plan (map [(Cut 1560.0, 1); (Cut 1820.0, 1); (Cut 2200.0, 1)])\r8 | Plan (map [(Cut 1560.0, 1); (Cut 1880.0, 1); (Cut 2150.0, 1)])\r1 | Plan (map [(Cut 1560.0, 2); (Cut 2050.0, 1)])\r2 | Plan (map [(Cut 1710.0, 1); (Cut 1820.0, 1); (Cut 2050.0, 1)])\r6 | Plan (map [(Cut 1710.0, 2); (Cut 2140.0, 1)])\r7 | Plan (map [(Cut 1820.0, 2); (Cut 1930.0, 1)])\r==========================================\rTotal Number of Cuts: 73\r==========================================\rIf you check the Wikipedia article, you will see that the best possible answer is 73. There are multiple, equally good solutions. This is called Degeneracy. Problems with high levels of Degeneracy can be difficult to solve but fortunately this one was not. You may run this code on your machine and get a different set of plans, but you’ll still have a total of 73 stock rolls required.\nNext Steps This was a fun challenge and was a bit of a brain teaser. These types of problems are everywhere in manufacturing planning and scheduling. Minimizing the amount of raw resources required is incredibly important but can be brutally difficult. It’s often done by domain experts spending hours with Excel finding a plan that meets all the requirements. These are some of my favorite problems to turn into Mathematical Planning models. Thank you for your time and I look forward to chatting next week!\n",
  "wordCount" : "2072",
  "inLanguage": "en",
  "datePublished": "2021-01-11T00:00:00Z",
  "dateModified": "2021-01-11T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://matthewcrews.com/blog/2021/01/2021-01-11/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Matthew Crews",
    "logo": {
      "@type": "ImageObject",
      "url": "https://matthewcrews.com/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://matthewcrews.com" accesskey="h" title="Matthew Crews (Alt + H)">Matthew Crews</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://matthewcrews.com/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://matthewcrews.com/consulting" title="Consulting">
                    <span>Consulting</span>
                </a>
            </li>
            <li>
                <a href="https://matthewcrews.com/mathematical-planning" title="Mathamatical Planning">
                    <span>Mathamatical Planning</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Minimizing Waste for the Cutting Stock Problem
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">January 11, 2021

    </div>
  </header> 

  <div class="post-content">
<p>I was recently posed the question, &ldquo;Can you use Mathematical Planning to optimize the Cutting Stock problem?&rdquo; For those who are not familiar with this problem, you can find the Wikipedia article <a href="https://en.wikipedia.org/wiki/Cutting_stock_problem">here</a>. In summary, you have a stock size of paper material from which you need to produce smaller sizes. In the example provided on Wikipedia, the stock size is 5600mm. You are asked to produce a variety of sizes between 1380mm and 2200mm. The ideal plan is one which minimizes the amount of waste. This is a classic planning problem that can actually be reduced to the <a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack problem</a>.</p>
<blockquote>
<p><strong>Note</strong>: Full code for this post can be found <a href="https://github.com/matthewcrews/modelmondays/blob/main/CuttingStockProblem.fsx">here</a></p>
</blockquote>
<p>These are the cut lengths and quantities you need to produce in the example problem.</p>
<table>
<thead>
<tr>
<th>Width [mm]</th>
<th>Number of Items</th>
</tr>
</thead>
<tbody>
<tr>
<td>1380</td>
<td>22</td>
</tr>
<tr>
<td>1520</td>
<td>25</td>
</tr>
<tr>
<td>1560</td>
<td>12</td>
</tr>
<tr>
<td>1710</td>
<td>14</td>
</tr>
<tr>
<td>1820</td>
<td>18</td>
</tr>
<tr>
<td>1880</td>
<td>18</td>
</tr>
<tr>
<td>1930</td>
<td>20</td>
</tr>
<tr>
<td>2000</td>
<td>10</td>
</tr>
<tr>
<td>2050</td>
<td>12</td>
</tr>
<tr>
<td>2100</td>
<td>14</td>
</tr>
<tr>
<td>2140</td>
<td>16</td>
</tr>
<tr>
<td>2150</td>
<td>18</td>
</tr>
<tr>
<td>2200</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>There are a variety of different ways you can cut the stock size into the smaller sizes. For example, you could produce 3 x 1820mm cuts from a 5600mm stock roll. You could also do 2200mm, 1820mm, and 1560mm. In total there are 308 possible combinations of cuts, not including the empty combination which has zero cuts. The most important thing to realize when approaching this problem is that the order you make the cuts does not matter. A more technical term would be that the order of cuts is <a href="https://en.wikipedia.org/wiki/Commutative_property">commutative</a>.</p>
<h2 id="generating-the-possible-cuts">Generating the Possible Cuts<a hidden class="anchor" aria-hidden="true" href="#generating-the-possible-cuts">#</a></h2>
<p>The most difficult part of this problem turned out to be the generating of the possible cuts. Before we dive right into that though, let&rsquo;s create some simple domain types to describe our problem.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Cut</span> <span style="color:#f92672">=</span> Cut <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">float</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Plan</span> <span style="color:#f92672">=</span> Plan <span style="color:#66d9ef">of</span> Map<span style="color:#f92672">&lt;</span>Cut<span style="color:#f92672">,</span> int<span style="color:#f92672">&gt;</span>
</code></pre></div><p>A <code>Cut</code> is a length we want to create from our stock rolls. A <code>Plan</code> is a set of cuts. We want an algorithm which will generate the possible <code>Plan</code>s for a set of <code>Cut</code>s for our stock roll. To make our lives easier, I am going to go ahead and write some functions which allow us to work with these types more easily.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">module</span> Cut <span style="color:#f92672">=</span>

    <span style="color:#e6db74">/// Take a Cut and return the length as a float
</span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">let</span> length <span style="color:#f92672">(</span>Cut length<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
        length

<span style="color:#66d9ef">module</span> Plan <span style="color:#f92672">=</span>

    <span style="color:#e6db74">/// Give me a Plan with no cuts
</span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">let</span> empty <span style="color:#f92672">:</span> Plan <span style="color:#f92672">=</span>
        Plan Map.empty

    <span style="color:#e6db74">/// Give me the total length of cuts in the plan
</span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">let</span> length <span style="color:#f92672">(</span>Plan plan<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
       plan
       <span style="color:#f92672">|&gt;</span> Seq.sumBy <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">(</span>KeyValue<span style="color:#f92672">(</span>Cut cut<span style="color:#f92672">,</span> count<span style="color:#f92672">))</span> <span style="color:#f92672">-&gt;</span> cut <span style="color:#f92672">*</span> <span style="color:#66d9ef">float</span> count<span style="color:#f92672">)</span>

    <span style="color:#e6db74">/// Add a Cut to a Plan and return a new Plan
</span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">let</span> addCut <span style="color:#f92672">(</span>cut<span style="color:#f92672">:</span> Cut<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>Plan plan<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">match</span> Map.tryFind cut plan <span style="color:#66d9ef">with</span>
        <span style="color:#f92672">|</span> Some count <span style="color:#f92672">-&gt;</span> Plan <span style="color:#f92672">(</span>Map.add cut <span style="color:#f92672">(</span>count <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> plan<span style="color:#f92672">)</span>
        <span style="color:#f92672">|</span> None <span style="color:#f92672">-&gt;</span> Plan <span style="color:#f92672">(</span>Map.add cut 1 plan<span style="color:#f92672">)</span>

    <span style="color:#e6db74">/// Give me the count of each distinct cut in a given Plan
</span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">let</span> cutCounts <span style="color:#f92672">(</span>Plan plan<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
        plan
        <span style="color:#f92672">|&gt;</span> Seq.map <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">(</span>KeyValue<span style="color:#f92672">(</span>cut<span style="color:#f92672">,</span> count<span style="color:#f92672">))</span> <span style="color:#f92672">-&gt;</span> cut<span style="color:#f92672">,</span> count<span style="color:#f92672">)</span>
</code></pre></div><p>We now have our domain for working in this space. Let&rsquo;s talk about the function which will generate the possible <code>Plan</code>s given a set of <code>Cut</code>s and a Stock Length. We want something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> generatePlans <span style="color:#f92672">(</span>stockLength<span style="color:#f92672">:</span> <span style="color:#66d9ef">float</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>cuts<span style="color:#f92672">:</span> Cut <span style="color:#66d9ef">list</span><span style="color:#f92672">)</span> <span style="color:#f92672">:</span> Plan <span style="color:#66d9ef">list</span> <span style="color:#f92672">=</span>
    <span style="color:#75715e">// Do some magic here??
</span></code></pre></div><p>Now, I&rsquo;m going to show you the answer that I came up with. What you are not seeing though is the couple of hours I spent with my notebook sketching out how this would work. It was not intuitive to me, so I don&rsquo;t want you to think that this stuff just materializes out of thin air. I had to struggle. It was not intuitive but by the time I was done, I felt immense satisfaction.</p>
<p>The first thing I am going to do is sort <code>cuts</code> from the shortest length to the longest and ensure that I only have distinct cuts.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> sortedCuts <span style="color:#f92672">=</span> 
    cuts 
    <span style="color:#f92672">|&gt;</span> List.distinct
    <span style="color:#f92672">|&gt;</span> List.sortBy <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">(</span>Cut length<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> length<span style="color:#f92672">)</span>
</code></pre></div><p>This algorithm is going to take advantage of the fact that the cuts are sorted from shortest to longest so that it can terminate early. Now I want to write a recursive function which is going to take an initially empty <code>Plan</code> and try adding cuts to it. It will keep adding cuts until it exceeds the Stock Length. You can think of this as a sort of <a href="https://en.wikipedia.org/wiki/Constructive_heuristic">Constructive Heuristic</a>. I&rsquo;m going to show you the full function but then we will unpack it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> rec generate <span style="color:#f92672">(</span>candidates<span style="color:#f92672">:</span> <span style="color:#f92672">(</span>Plan <span style="color:#f92672">*</span> Cut <span style="color:#66d9ef">list</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">list</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>approved<span style="color:#f92672">:</span> Plan <span style="color:#66d9ef">list</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">match</span> candidates <span style="color:#66d9ef">with</span>
    <span style="color:#f92672">|</span> [] <span style="color:#f92672">-&gt;</span> approved
    <span style="color:#f92672">|</span> testCandidate<span style="color:#f92672">::</span>remainingCandidates <span style="color:#f92672">-&gt;</span>
        <span style="color:#66d9ef">let</span> plan<span style="color:#f92672">,</span> cuts <span style="color:#f92672">=</span> testCandidate
        <span style="color:#66d9ef">match</span> cuts <span style="color:#66d9ef">with</span>
        <span style="color:#f92672">|</span> [] <span style="color:#f92672">-&gt;</span> 
            <span style="color:#66d9ef">let</span> newApproved <span style="color:#f92672">=</span> plan<span style="color:#f92672">::</span>approved
            generate remainingCandidates newApproved
        <span style="color:#f92672">|</span> nextCut<span style="color:#f92672">::</span>remainingCuts <span style="color:#f92672">-&gt;</span>
            <span style="color:#66d9ef">if</span> Plan.length plan <span style="color:#f92672">+</span> Cut.length nextCut <span style="color:#f92672">&lt;=</span> stockLength <span style="color:#66d9ef">then</span>
                <span style="color:#66d9ef">let</span> newPlan <span style="color:#f92672">=</span> Plan.addCut nextCut plan
                <span style="color:#66d9ef">let</span> newCandidates <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>newPlan<span style="color:#f92672">,</span> cuts<span style="color:#f92672">)::(</span>plan<span style="color:#f92672">,</span> remainingCuts<span style="color:#f92672">)::</span>remainingCandidates
                generate newCandidates approved
            <span style="color:#66d9ef">else</span>
                <span style="color:#66d9ef">let</span> newApproved <span style="color:#f92672">=</span> plan<span style="color:#f92672">::</span>approved
                generate remainingCandidates newApproved
</code></pre></div><p>We have a list of plans and possible cuts which we are exploring called <code>candidates</code>. As candidates are approved, they are added to the <code>approved</code> list of plans. Keep in mind, this function will be initially called with an empty <code>Plan</code> and the full list of <code>Cut</code>s available. Let&rsquo;s go through the cases step by step.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">match</span> candidates <span style="color:#66d9ef">with</span>
<span style="color:#f92672">|</span> [] <span style="color:#f92672">-&gt;</span> approved
</code></pre></div><p>This is the terminal case. We have evaluated all the <code>Plan</code>s that were generated, and we return the <code>Plan</code>s in the <code>approved</code> list. Now for the case where we still have remaining candidates.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#f92672">|</span> testCandidate<span style="color:#f92672">::</span>remainingCandidates <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">let</span> plan<span style="color:#f92672">,</span> cuts <span style="color:#f92672">=</span> testCandidate
</code></pre></div><p>In this case, there is at least one remaining candidate to evaluate, <code>testCandidate</code>. We create <code>plan</code> and <code>cuts</code> values using structural unpacking of <code>testCandidate</code>. <code>plan</code> is the <code>Plan</code> we are testing. <code>cuts</code> is the list of possible cuts we can add to <code>plan</code>. You will see that this list will shrink as our algorithm continues.</p>
<p>Now let&rsquo;s match against the list of <code>Cut</code>s to see what we should do.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">match</span> cuts <span style="color:#66d9ef">with</span>
<span style="color:#f92672">|</span> [] <span style="color:#f92672">-&gt;</span> 
    <span style="color:#66d9ef">let</span> newApproved <span style="color:#f92672">=</span> plan<span style="color:#f92672">::</span>approved
    generate remainingCandidates newApproved
</code></pre></div><p>If the list of cuts is empty, as indicated by the <code>[]</code> case, then we create <code>newApproved</code> by adding <code>plan</code> to <code>approved</code> and calling <code>generate</code> again. Now let&rsquo;s look at the case where there are <code>Cut</code>s remaining.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#f92672">|</span> nextCut<span style="color:#f92672">::</span>remainingCuts <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">if</span> Plan.length plan <span style="color:#f92672">+</span> Cut.length nextCut <span style="color:#f92672">&lt;=</span> stockLength <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">let</span> newPlan <span style="color:#f92672">=</span> Plan.addCut nextCut plan
        <span style="color:#66d9ef">let</span> newCandidates <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>newPlan<span style="color:#f92672">,</span> cuts<span style="color:#f92672">)::(</span>plan<span style="color:#f92672">,</span> remainingCuts<span style="color:#f92672">)::</span>remainingCandidates
        generate newCandidates approved
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">let</span> newApproved <span style="color:#f92672">=</span> plan<span style="color:#f92672">::</span>approved
        generate remainingCandidates newApproved
</code></pre></div><p>We now look at <code>nextCut</code> which we know is the shortest of the <code>Cut</code>s in the list due to our sorting. We check that if we add this <code>Cut</code> to <code>plan</code> whether we will exceed the <code>stockLength</code> limit. If we do not exceed the limit, we create a new plan <code>newPlan</code>. We will add <code>newPlan</code> to the list of <code>candidates</code> with <code>cuts</code> as the list of possible <code>Cut</code>s to explore. We also add the current <code>Plan</code> we are testing, <code>plan</code>, to the list of <code>candidates</code> but now with <code>remainingCuts</code> as the possible <code>Cut</code>s to add. Take your time with that. That puzzle took me awhile to figure out.</p>
<p>In the case that the length of <code>nextCut</code> is too long, we add <code>plan</code> to <code>approved</code> and then continue to search the remaining <code>candidates</code>.</p>
<p>We call our recursive function with an empty <code>Plan</code> to start and the full list of <code>Cut</code>s to get all the possible <code>Plan</code>s we would want to consider.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> initialCandidate <span style="color:#f92672">=</span> Plan.empty<span style="color:#f92672">,</span> sortedCuts
generate <span style="color:#f92672">[</span>initialCandidate<span style="color:#f92672">]</span> []
</code></pre></div><h2 id="the-optimization-problem">The Optimization Problem<a hidden class="anchor" aria-hidden="true" href="#the-optimization-problem">#</a></h2>
<p>The optimization model for this is rather simple. We will create the list of possible <code>Plan</code>s using the function we just described. We will associate an integer <code>Decision</code> with each <code>Plan</code> which is to indicate how many of each of those plans we will schedule. Let&rsquo;s setup the data for our model so that we can build it. All this data is taken from the Wikipedia example.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> cuts <span style="color:#f92672">=</span> 
    <span style="color:#f92672">[</span>
        1380<span style="color:#f92672">.</span>0
        1520<span style="color:#f92672">.</span>0
        1560<span style="color:#f92672">.</span>0
        1710<span style="color:#f92672">.</span>0
        1820<span style="color:#f92672">.</span>0
        1880<span style="color:#f92672">.</span>0
        1930<span style="color:#f92672">.</span>0
        2000<span style="color:#f92672">.</span>0
        2050<span style="color:#f92672">.</span>0
        2100<span style="color:#f92672">.</span>0
        2140<span style="color:#f92672">.</span>0
        2150<span style="color:#f92672">.</span>0
        2200<span style="color:#f92672">.</span>0
    <span style="color:#f92672">]</span> <span style="color:#f92672">|&gt;</span> List.map Cut

<span style="color:#66d9ef">let</span> cutRequirements <span style="color:#f92672">=</span>
    <span style="color:#f92672">[</span>
        Cut 1380<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 22<span style="color:#f92672">.</span>0
        Cut 1520<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 25<span style="color:#f92672">.</span>0
        Cut 1560<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 12<span style="color:#f92672">.</span>0
        Cut 1710<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 14<span style="color:#f92672">.</span>0
        Cut 1820<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 18<span style="color:#f92672">.</span>0
        Cut 1880<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 18<span style="color:#f92672">.</span>0
        Cut 1930<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 20<span style="color:#f92672">.</span>0
        Cut 2000<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 10<span style="color:#f92672">.</span>0
        Cut 2050<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 12<span style="color:#f92672">.</span>0
        Cut 2100<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 14<span style="color:#f92672">.</span>0
        Cut 2140<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 16<span style="color:#f92672">.</span>0
        Cut 2150<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 18<span style="color:#f92672">.</span>0
        Cut 2200<span style="color:#f92672">.</span>0 <span style="color:#f92672">,</span> 20<span style="color:#f92672">.</span>0
    <span style="color:#f92672">]</span> <span style="color:#f92672">|&gt;</span> Map

<span style="color:#66d9ef">let</span> stockLength <span style="color:#f92672">=</span> 5600<span style="color:#f92672">.</span>0
<span style="color:#66d9ef">let</span> plans <span style="color:#f92672">=</span> generatePlans stockLength cuts
</code></pre></div><p>We now want to start building our model. We&rsquo;ll open the namespaces we need and create our set of <code>Decision</code>s associated with each <code>Plan</code> in <code>plans</code>. We are using <a href="http://matthewcrews.com/SliceMap/#/">SliceMaps</a> to simplify formulation.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">open</span> Flips
<span style="color:#66d9ef">open</span> Flips.Types
<span style="color:#66d9ef">open</span> Flips.SliceMap

<span style="color:#66d9ef">let</span> planDecs <span style="color:#f92672">=</span>
    DecisionBuilder <span style="color:#e6db74">&#34;PlanCount&#34;</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> plan <span style="color:#66d9ef">in</span> plans <span style="color:#f92672">-&gt;</span>
        Integer <span style="color:#f92672">(</span>0<span style="color:#f92672">.</span>0<span style="color:#f92672">,</span> infinity<span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span> <span style="color:#f92672">|&gt;</span> SMap
</code></pre></div><p>We then need to calculate the number of each <code>Cut</code> that is associated with each <code>Plan</code>. This will be important for us to formulate the constraints around meeting the minimum cut requirements. We will store this information in a 2-D <code>SliceMap</code> where the first index is the <code>Plan</code> and the second index is the <code>Cut</code>. The value in the <code>SliceMap</code> is the number of a given <code>Cut</code> in the <code>Plan</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> planCutCounts <span style="color:#f92672">=</span>
    plans
    <span style="color:#f92672">|&gt;</span> Seq.collect <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> plan <span style="color:#f92672">-&gt;</span> Plan.cutCounts plan
                                <span style="color:#f92672">|&gt;</span> Seq.map <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">(</span>cut<span style="color:#f92672">,</span> count<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>plan<span style="color:#f92672">,</span> cut<span style="color:#f92672">),</span> <span style="color:#66d9ef">float</span> count<span style="color:#f92672">)</span>
    <span style="color:#f92672">)</span> <span style="color:#f92672">|&gt;</span> SMap2
</code></pre></div><p>It&rsquo;s now actually simple to create our constraints. We will create a constraint for each <code>Cut</code> in our data stating that the solution must meet the minimum quantity of each <code>Cut</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> cutRequirementConstraints <span style="color:#f92672">=</span>
    ConstraintBuilder <span style="color:#e6db74">&#34;CutRequirements&#34;</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> cut <span style="color:#66d9ef">in</span> cuts <span style="color:#f92672">-&gt;</span>
        sum <span style="color:#f92672">(</span>planDecs <span style="color:#f92672">.*</span> planCutCounts<span style="color:#f92672">.[</span>All<span style="color:#f92672">,</span> cut<span style="color:#f92672">])</span> <span style="color:#f92672">&gt;==</span> cutRequirements<span style="color:#f92672">.[</span>cut<span style="color:#f92672">]</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>Our objective is to minimize the total number of stock rolls required to meet the demand for each <code>Cut</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> objective <span style="color:#f92672">=</span> Objective.create <span style="color:#e6db74">&#34;MinRolls&#34;</span> Minimize <span style="color:#f92672">(</span>sum planDecs<span style="color:#f92672">)</span>
</code></pre></div><p>We combine these into our model and solve.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> model <span style="color:#f92672">=</span>
    Model.create objective
    <span style="color:#f92672">|&gt;</span> Model.addConstraints cutRequirementConstraints

<span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> Solver.solve Settings.basic model
</code></pre></div><p>Let&rsquo;s go ahead and provide some nice printing of the results to the console.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">match</span> result <span style="color:#66d9ef">with</span>
<span style="color:#f92672">|</span> Optimal solution <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">let</span> values <span style="color:#f92672">=</span> 
        Solution.getValues solution planDecs
        <span style="color:#f92672">|&gt;</span> Map.filter <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">_</span> quantity <span style="color:#f92672">-&gt;</span> quantity <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">.</span>0<span style="color:#f92672">)</span>

    <span style="color:#66d9ef">let</span> totalNumberOfRolls <span style="color:#f92672">=</span>
        values
        <span style="color:#f92672">|&gt;</span> Seq.sumBy <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">(</span>KeyValue<span style="color:#f92672">(_,</span> count<span style="color:#f92672">))</span> <span style="color:#f92672">-&gt;</span> count<span style="color:#f92672">)</span>

    printfn <span style="color:#e6db74">&#34;Quantity | Plan&#34;</span>
    <span style="color:#66d9ef">for</span> KeyValue<span style="color:#f92672">(</span>plan<span style="color:#f92672">,</span> quantity<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span> values <span style="color:#66d9ef">do</span>
        printfn <span style="color:#f92672">$</span><span style="color:#e6db74">&#34;%8.0f{quantity} | {plan}&#34;</span>

    printfn <span style="color:#e6db74">&#34;==========================================&#34;</span>
    printfn <span style="color:#f92672">$</span><span style="color:#e6db74">&#34;Total Number of Rolls: {totalNumberOfRolls}&#34;</span>
    printfn <span style="color:#e6db74">&#34;==========================================&#34;</span>

<span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> failwith <span style="color:#e6db74">&#34;Unable to solve&#34;</span>
</code></pre></div><p>When you run the full script, you will see the following printed out.</p>
<pre><code class="language-terminal" data-lang="terminal">Quantity | Plan
8 | Plan (map [(Cut 1380.0, 1); (Cut 2000.0, 1); (Cut 2200.0, 1)])
7 | Plan (map [(Cut 1380.0, 1); (Cut 2050.0, 1); (Cut 2150.0, 1)])
7 | Plan (map [(Cut 1380.0, 1); (Cut 2100.0, 2)])
10 | Plan (map [(Cut 1520.0, 1); (Cut 1880.0, 1); (Cut 2200.0, 1)])
10 | Plan (map [(Cut 1520.0, 1); (Cut 1930.0, 1); (Cut 2140.0, 1)])
3 | Plan (map [(Cut 1520.0, 1); (Cut 1930.0, 1); (Cut 2150.0, 1)])
2 | Plan (map [(Cut 1520.0, 1); (Cut 2000.0, 1); (Cut 2050.0, 1)])
2 | Plan (map [(Cut 1560.0, 1); (Cut 1820.0, 1); (Cut 2200.0, 1)])
8 | Plan (map [(Cut 1560.0, 1); (Cut 1880.0, 1); (Cut 2150.0, 1)])
1 | Plan (map [(Cut 1560.0, 2); (Cut 2050.0, 1)])
2 | Plan (map [(Cut 1710.0, 1); (Cut 1820.0, 1); (Cut 2050.0, 1)])
6 | Plan (map [(Cut 1710.0, 2); (Cut 2140.0, 1)])
7 | Plan (map [(Cut 1820.0, 2); (Cut 1930.0, 1)])
==========================================
Total Number of Cuts: 73
==========================================
</code></pre><p>If you check the Wikipedia article, you will see that the best possible answer is 73. There are multiple, equally good solutions. This is called Degeneracy. Problems with high levels of Degeneracy can be difficult to solve but fortunately this one was not. You may run this code on your machine and get a different set of plans, but you&rsquo;ll still have a total of 73 stock rolls required.</p>
<h2 id="next-steps">Next Steps<a hidden class="anchor" aria-hidden="true" href="#next-steps">#</a></h2>
<p>This was a fun challenge and was a bit of a brain teaser. These types of problems are everywhere in manufacturing planning and scheduling. Minimizing the amount of raw resources required is incredibly important but can be brutally difficult. It&rsquo;s often done by domain experts spending hours with Excel finding a plan that meets all the requirements. These are some of my favorite problems to turn into Mathematical Planning models. Thank you for your time and I look forward to chatting next week!</p>

</div>
  <footer class="post-footer">



<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Minimizing Waste for the Cutting Stock Problem on twitter"
        href="https://twitter.com/intent/tweet/?text=Minimizing%20Waste%20for%20the%20Cutting%20Stock%20Problem&amp;url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f01%2f2021-01-11%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Minimizing Waste for the Cutting Stock Problem on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f01%2f2021-01-11%2f&amp;title=Minimizing%20Waste%20for%20the%20Cutting%20Stock%20Problem&amp;summary=Minimizing%20Waste%20for%20the%20Cutting%20Stock%20Problem&amp;source=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f01%2f2021-01-11%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Minimizing Waste for the Cutting Stock Problem on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f01%2f2021-01-11%2f&title=Minimizing%20Waste%20for%20the%20Cutting%20Stock%20Problem">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Minimizing Waste for the Cutting Stock Problem on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f01%2f2021-01-11%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Minimizing Waste for the Cutting Stock Problem on whatsapp"
        href="https://api.whatsapp.com/send?text=Minimizing%20Waste%20for%20the%20Cutting%20Stock%20Problem%20-%20https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f01%2f2021-01-11%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Minimizing Waste for the Cutting Stock Problem on telegram"
        href="https://telegram.me/share/url?text=Minimizing%20Waste%20for%20the%20Cutting%20Stock%20Problem&amp;url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f01%2f2021-01-11%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://matthewcrews.com">Matthew Crews</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    MathJax = {
    tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
    };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</body>

</html>
