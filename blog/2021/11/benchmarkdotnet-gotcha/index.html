<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>BenchmarkDotNet Gotcha with F# | Matthew Crews</title>

<meta name="keywords" content="" />
<meta name="description" content="I have been working on creating some types which allow me to wrap an array and index it with an int which has a Unit of Measure (UoM). Right now, if you want to index into an array with an int that has a UoM, you need to remove the units.
[&lt;Measure&gt;] type ItemIdx let a = [|1.0 .. 10.0|] let idx = 1&lt;ItemIdx&gt; let x = a[idx] // This will raise an error saying that the type `int&lt;ItemIdx&gt;` is not correct  let y = a[int idx] // This will work because the units are removed when calling `int` You may think, &ldquo;Matthew, that call to int is going to cause a problem, isn&rsquo;t it?">
<meta name="author" content="">
<link rel="canonical" href="https://matthewcrews.com/blog/2021/11/benchmarkdotnet-gotcha/" />
<link href="/assets/css/stylesheet.min.d5d820de85dae34a78c22303e07aa685bb90ec25a056c702c0b1a964ca68861d.css" integrity="sha256-1dgg3oXa40p4wiMD4HqmhbuQ7CWgVscCwLGpZMpohh0=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://matthewcrews.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://matthewcrews.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://matthewcrews.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://matthewcrews.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://matthewcrews.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.78.2" />


<meta property="og:title" content="BenchmarkDotNet Gotcha with F#" />
<meta property="og:description" content="I have been working on creating some types which allow me to wrap an array and index it with an int which has a Unit of Measure (UoM). Right now, if you want to index into an array with an int that has a UoM, you need to remove the units.
[&lt;Measure&gt;] type ItemIdx let a = [|1.0 .. 10.0|] let idx = 1&lt;ItemIdx&gt; let x = a[idx] // This will raise an error saying that the type `int&lt;ItemIdx&gt;` is not correct  let y = a[int idx] // This will work because the units are removed when calling `int` You may think, &ldquo;Matthew, that call to int is going to cause a problem, isn&rsquo;t it?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://matthewcrews.com/blog/2021/11/benchmarkdotnet-gotcha/" />
<meta property="article:published_time" content="2021-11-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-11-16T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="BenchmarkDotNet Gotcha with F#"/>
<meta name="twitter:description" content="I have been working on creating some types which allow me to wrap an array and index it with an int which has a Unit of Measure (UoM). Right now, if you want to index into an array with an int that has a UoM, you need to remove the units.
[&lt;Measure&gt;] type ItemIdx let a = [|1.0 .. 10.0|] let idx = 1&lt;ItemIdx&gt; let x = a[idx] // This will raise an error saying that the type `int&lt;ItemIdx&gt;` is not correct  let y = a[int idx] // This will work because the units are removed when calling `int` You may think, &ldquo;Matthew, that call to int is going to cause a problem, isn&rsquo;t it?"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "BenchmarkDotNet Gotcha with F#",
  "name": "BenchmarkDotNet Gotcha with F#",
  "description": "I have been working on creating some types which allow me to wrap an array and index it with an int which has a Unit of Measure (UoM). Right now, if you want to index into an array …",
  "keywords": [
    
  ],
  "articleBody": "I have been working on creating some types which allow me to wrap an array and index it with an int which has a Unit of Measure (UoM). Right now, if you want to index into an array with an int that has a UoM, you need to remove the units.\n[Measure] type ItemIdx let a = [|1.0 .. 10.0|] let idx = 1ItemIdx let x = a[idx] // This will raise an error saying that the type `int` is not correct  let y = a[int idx] // This will work because the units are removed when calling `int` You may think, “Matthew, that call to int is going to cause a problem, isn’t it?” That’s a great question. Let’s put together an experiment and see what assembly is generated. This code…\nlet test (a: arrayfloat) = let x = 1 a[x] Will generate this assembly.\n; Core CLR 6.0.21.52210 on amd64\r_.test(System.Double[])\rL0000: sub rsp, 0x28\rL0004: vzeroupper\rL0007: cmp dword ptr [rcx+8], 1\rL000b: jbe short L0017\rL000d: vmovsd xmm0, [rcx+0x18]\rL0012: add rsp, 0x28\rL0016: ret\rL0017: call 0x00007ffd109ee750\rL001c: int3\rLet’s add a UoM to the index and see what happens when we use it to index into the array while using int to remove the units.\n[Measure] type ItemIdx let test (a: arrayfloat) = let x = 1ItemIdx a[int x] // Does calling `int` here incur a performance penalty? And here is the assembly…\n; Core CLR 6.0.21.52210 on amd64\r_.test(System.Double[])\rL0000: sub rsp, 0x28\rL0004: vzeroupper\rL0007: cmp dword ptr [rcx+8], 1\rL000b: jbe short L0017\rL000d: vmovsd xmm0, [rcx+0x18]\rL0012: add rsp, 0x28\rL0016: ret\rL0017: call 0x00007ffd109ee750\rL001c: int3\rYou should notice that we are getting the exact same result. The F# compiler is smart enough to see that we are calling the int conversion function on a type that is already an int so it removes it.\nThis kind of thing is annoying to have to do manually all the time and I really wanted a wrapper around an array which had a UoM type associated with the index. I decided to code up something simple.\ntype ClassWrapperMeasure] 'Measure, 'Value(values: array'Value) = member _.Values = values member this.Item with get (idx: int'Measure) = this.Values.[int idx] member this.Length = LanguagePrimitives.Int32WithMeasure'Measure this.Values.Length We now have a class which is taking an array as part of its constructor and it is giving us a view of the underlying array which is forcing the use of an int with a UoM to retrieve values. This allows us to do the following.\n[Measure] type ItemIdx let classWrapper = [|1.0 .. (float numberCount)|] | ClassWrapperItemIdx, float ClassWrapper will now force us to use an int to retrieve values. You may think this is cumbersome but if you are working with many arrays simultaneously it can be easy to mix up which index is meant to be associated with which array. I like the compiler to be able to help me out so the idea of using UoM as a way provide some guarantees is nice provided there is not a speed penalty.\nI also thought, “You know, why not use a Struct instead of a Class to wrap the value? Using a Struct means the reference to the array will be on the stack, right? That should save you chasing a reference before getting to the array.” Rather than assuming that was the case I decided to put together a test using BenchmarkDotNet to verify my assumption was correct.\nThe Setup The first thing I need to do is define a Struct for wrapping my array.\n[Struct] type StructWrapperMeasure] 'Measure, 'Value = val Values : array'Value new (values: array'Value) = { Values = values } member inline this.Item with inline get (idx: int'Measure) = this.Values[int idx] member this.Length = LanguagePrimitives.Int32WithMeasure'Measure this.Values.Length Then I setup some test data. I typically am working with small arrays so I’m just going to be summing up the values from 1.0 to 100.0 and I’ll perform that 100,000 times. I create my three different types for my testing.\nlet iterations = 100_000 let numberCount = 100 let rawArray = [|1.0 .. (float numberCount)|] let classWrapper = [|1.0 .. (float numberCount)|] | ClassWrapperItemIdx, float let structWrapper = [|1.0 .. (float numberCount)|] | StructWrapperItemIdx, _ Alright, data prepared, time to create some tests. I open the namespaces I need from BenchmarkDotNet and create my Benchmark class. I create three tests to see which approach is faster. I’m assuming that the raw array is the absolute limit (short of SIMD).\ntype Benchmarks () = [Benchmark] member _.RawArray () = let mutable iterationIdx = 0 let mutable result = 0.0 while iterationIdx  iterations do let mutable idx = 0 let len = rawArray.Length while idx  len do result  result + rawArray[idx] idx  idx + 1 result  0.0 // Reset  iterationIdx  iterationIdx + 1 result [Benchmark] member _.ClassWrapper () = let mutable iterationIdx = 0 let mutable result = 0.0 while iterationIdx  iterations do let mutable idx = 0ItemIdx let len = classWrapper.Length while idx  len do result  result + classWrapper[idx] idx  idx + 1ItemIdx result  0.0 // Reset  iterationIdx  iterationIdx + 1 result [Benchmark] member _.StructWrapper () = let mutable iterationIdx = 0 let mutable result = 0.0 while iterationIdx  iterations do let mutable idx = 0ItemIdx let len = structWrapper.Length while idx  len do result  result + structWrapper[idx] idx  idx + 1ItemIdx result  0.0 // Reset  iterationIdx  iterationIdx + 1 result I run the benchmarks and get an unexpected result.\n   Method Mean Error StdDev     RawArray 6.434 ms 0.1241 ms 0.1100 ms   ClassWrapper 6.969 ms 0.1177 ms 0.1101 ms   StructWrapper 23.983 ms 0.2800 ms 0.2619 ms    I am shocked that the StructWrapper performed so much more poorly that either the RawArray or ClassWrapper. This does not make any sense to me. If anything, StructWrapper should be faster than ClassWrapper but these numbers aren’t lying. The .NET Runtime has some special optimizations it can perform for Struct. In .NET 6.0 this includes keeping the values of the struct in the registers. You can check out the work here\nThe Fix I go to StackOverflow and Twitter to see if anyone had insight into what is going on. Upon the recommendation of Phillip Carter I move the code for generating the test data to inside the Benchmark class. When I do this, I get these results.\n   Method Mean Error StdDev     InternalRawArray 5.788 ms 0.0241 ms 0.0225 ms   InternalClassWrapper 5.983 ms 0.0174 ms 0.0154 ms   InternalStructWrapper 5.980 ms 0.0423 ms 0.0396 ms    Now the performance is roughly equivalent. Apparently, there are some gotchas with the BenchmarkDotNet library and F# modules. I go ahead and define some additional types for wrapping an array. I wrap an array using a Record and a Record with the [] attribute. I create tests where the data is defined inside the Benchmark class and tests where the data is defined in a separate module. Here is what I ended up finding.\n   Method Mean Error StdDev     InternalRawArray 5.839 ms 0.0517 ms 0.0431 ms   ExternalRawArray 6.537 ms 0.0429 ms 0.0401 ms   InternalClassWrapper 5.866 ms 0.0183 ms 0.0203 ms   ExternalClassWrapper 6.903 ms 0.0734 ms 0.0686 ms   InternalStructWrapper 6.032 ms 0.0933 ms 0.0827 ms   ExternalStructWrapper 21.042 ms 0.0932 ms 0.0826 ms   InternalRecordApproach 5.920 ms 0.0728 ms 0.0608 ms   ExternalRecordApproach 6.899 ms 0.0760 ms 0.0674 ms   InternalStructRecordApproach 5.899 ms 0.0947 ms 0.1297 ms   ExternalStructRecordApproach 5.841 ms 0.0576 ms 0.0450 ms    As you can see, I stumbled upon what appears to be a single outlier. You can also see that across the board the tests that are operating on data defined inside the Benchmark class outperform those where the data is defined externally. The only exception is the Struct Record but the difference in means is withen the noise of the tests. I think it’s important for an F# developer whose looking for performance to be aware that where data is declared can affect your benchmarks and could lead to incorrect conclusions. The guidance I received from Phillip was to declare the data in the Benchmark class. Bartosz Adamczewski recommends writing the library code in F# and the benchmarks in C#. This makes sense as I believe the BenchmarkDotNet library considers the C# use case primarily.\nIf you would like to see the full set of tests you can check out the repo here. Until next time, stay safe out there and have fun with your benchmarking!\n",
  "wordCount" : "1415",
  "inLanguage": "en",
  "datePublished": "2021-11-16T00:00:00Z",
  "dateModified": "2021-11-16T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://matthewcrews.com/blog/2021/11/benchmarkdotnet-gotcha/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Matthew Crews",
    "logo": {
      "@type": "ImageObject",
      "url": "https://matthewcrews.com/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://matthewcrews.com" accesskey="h" title="Matthew Crews (Alt + H)">Matthew Crews</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://matthewcrews.com/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://matthewcrews.com/consulting" title="Consulting">
                    <span>Consulting</span>
                </a>
            </li>
            <li>
                <a href="https://matthewcrews.com/mathematical-planning" title="Mathamatical Planning">
                    <span>Mathamatical Planning</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      BenchmarkDotNet Gotcha with F#
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">November 16, 2021

    </div>
  </header> 

  <div class="post-content">
<p>I have been working on creating some types which allow me to wrap an array and index it with an <code>int</code> which has a Unit of Measure (UoM). Right now, if you want to index into an array with an <code>int</code> that has a UoM, you need to remove the units.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#f92672">[&lt;</span>Measure<span style="color:#f92672">&gt;]</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ItemIdx</span>

<span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#f92672">[|</span>1<span style="color:#f92672">.</span>0 <span style="color:#f92672">..</span> 10<span style="color:#f92672">.</span>0<span style="color:#f92672">|]</span>
<span style="color:#66d9ef">let</span> idx <span style="color:#f92672">=</span> 1<span style="color:#f92672">&lt;</span>ItemIdx<span style="color:#f92672">&gt;</span>

<span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#75715e">// This will raise an error saying that the type `int&lt;ItemIdx&gt;` is not correct
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>int idx<span style="color:#f92672">]</span> <span style="color:#75715e">// This will work because the units are removed when calling `int`
</span></code></pre></div><p>You may think, &ldquo;Matthew, that call to <code>int</code> is going to cause a problem, isn&rsquo;t it?&rdquo; That&rsquo;s a great question. Let&rsquo;s put together an experiment and see what assembly is generated. This code&hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> test <span style="color:#f92672">(</span>a<span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;)</span> <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> 1
    a<span style="color:#f92672">[</span>x<span style="color:#f92672">]</span>

</code></pre></div><p>Will generate this assembly.</p>
<pre><code class="language-assembly" data-lang="assembly">; Core CLR 6.0.21.52210 on amd64

_.test(System.Double[])
    L0000: sub rsp, 0x28
    L0004: vzeroupper
    L0007: cmp dword ptr [rcx+8], 1
    L000b: jbe short L0017
    L000d: vmovsd xmm0, [rcx+0x18]
    L0012: add rsp, 0x28
    L0016: ret
    L0017: call 0x00007ffd109ee750
    L001c: int3
</code></pre><p>Let&rsquo;s add a UoM to the index and see what happens when we use it to index into the array while using <code>int</code> to remove the units.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#f92672">[&lt;</span>Measure<span style="color:#f92672">&gt;]</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ItemIdx</span>

<span style="color:#66d9ef">let</span> test <span style="color:#f92672">(</span>a<span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;)</span> <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> 1<span style="color:#f92672">&lt;</span>ItemIdx<span style="color:#f92672">&gt;</span>
    a<span style="color:#f92672">[</span>int x<span style="color:#f92672">]</span> <span style="color:#75715e">// Does calling `int` here incur a performance penalty?
</span></code></pre></div><p>And here is the assembly&hellip;</p>
<pre><code class="language-assembly" data-lang="assembly">; Core CLR 6.0.21.52210 on amd64

_.test(System.Double[])
    L0000: sub rsp, 0x28
    L0004: vzeroupper
    L0007: cmp dword ptr [rcx+8], 1
    L000b: jbe short L0017
    L000d: vmovsd xmm0, [rcx+0x18]
    L0012: add rsp, 0x28
    L0016: ret
    L0017: call 0x00007ffd109ee750
    L001c: int3
</code></pre><p>You should notice that we are getting the exact same result. The F# compiler is smart enough to see that we are calling the <code>int</code> conversion function on a type that is already an <code>int</code> so it removes it.</p>
<p>This kind of thing is annoying to have to do manually all the time and I really wanted a wrapper around an <code>array</code> which had a UoM type associated with the index. I decided to code up something simple.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ClassWrapper</span><span style="color:#f92672">&lt;[&lt;</span>Measure<span style="color:#f92672">&gt;]</span> <span style="color:#66d9ef">&#39;</span>Measure<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>Value<span style="color:#f92672">&gt;(</span>values<span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>Value<span style="color:#f92672">&gt;)</span> <span style="color:#f92672">=</span>

    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">Values</span> <span style="color:#f92672">=</span> values

    <span style="color:#66d9ef">member</span> this.<span style="color:#a6e22e">Item</span>
        <span style="color:#66d9ef">with</span> get <span style="color:#f92672">(</span>idx<span style="color:#f92672">:</span> int<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>Measure<span style="color:#f92672">&gt;)</span> <span style="color:#f92672">=</span>
            this<span style="color:#f92672">.</span>Values<span style="color:#f92672">.[</span>int idx<span style="color:#f92672">]</span>

    <span style="color:#66d9ef">member</span> this.<span style="color:#a6e22e">Length</span> <span style="color:#f92672">=</span> 
        LanguagePrimitives.Int32WithMeasure<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>Measure<span style="color:#f92672">&gt;</span> this<span style="color:#f92672">.</span>Values<span style="color:#f92672">.</span>Length
</code></pre></div><p>We now have a class which is taking an <code>array&lt;'Value&gt;</code> as part of its constructor and it is giving us a view of the underlying <code>array</code> which is forcing the use of an <code>int</code> with a UoM to retrieve values. This allows us to do the following.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#f92672">[&lt;</span>Measure<span style="color:#f92672">&gt;]</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ItemIdx</span>

<span style="color:#66d9ef">let</span> classWrapper <span style="color:#f92672">=</span>
   <span style="color:#f92672">[|</span>1<span style="color:#f92672">.</span>0 <span style="color:#f92672">..</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">float</span> numberCount<span style="color:#f92672">)|]</span> 
   <span style="color:#f92672">|&gt;</span> ClassWrapper<span style="color:#f92672">&lt;</span>ItemIdx<span style="color:#f92672">,</span> <span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
</code></pre></div><p><code>ClassWrapper</code> will now force us to use an <code>int&lt;ItemIdx&gt;</code> to retrieve values. You may think this is cumbersome but if you are working with many arrays simultaneously it can be easy to mix up which index is meant to be associated with which array. I like the compiler to be able to help me out so the idea of using UoM as a way provide some guarantees is nice provided there is not a speed penalty.</p>
<p>I also thought, &ldquo;You know, why not use a Struct instead of a Class to wrap the value? Using a Struct means the reference to the array will be on the stack, right? That should save you chasing a reference before getting to the array.&rdquo; Rather than assuming that was the case I decided to put together a test using <a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet</a> to verify my assumption was correct.</p>
<h2 id="the-setup">The Setup<a hidden class="anchor" aria-hidden="true" href="#the-setup">#</a></h2>
<p>The first thing I need to do is define a Struct for wrapping my <code>array</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#f92672">[&lt;</span>Struct<span style="color:#f92672">&gt;]</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">StructWrapper</span><span style="color:#f92672">&lt;[&lt;</span>Measure<span style="color:#f92672">&gt;]</span> <span style="color:#66d9ef">&#39;</span>Measure<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>Value<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">val</span> Values <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>Value<span style="color:#f92672">&gt;</span>

    <span style="color:#66d9ef">new</span> <span style="color:#f92672">(</span>values<span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>Value<span style="color:#f92672">&gt;)</span> <span style="color:#f92672">=</span>
        <span style="color:#f92672">{</span>
            Values <span style="color:#f92672">=</span> values
        <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">member</span> <span style="color:#66d9ef">inline</span> this<span style="color:#f92672">.</span>Item
        <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">inline</span> get <span style="color:#f92672">(</span>idx<span style="color:#f92672">:</span> int<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>Measure<span style="color:#f92672">&gt;)</span> <span style="color:#f92672">=</span>
            this<span style="color:#f92672">.</span>Values<span style="color:#f92672">[</span>int idx<span style="color:#f92672">]</span>

    <span style="color:#66d9ef">member</span> this.<span style="color:#a6e22e">Length</span> <span style="color:#f92672">=</span> 
        LanguagePrimitives.Int32WithMeasure<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>Measure<span style="color:#f92672">&gt;</span> this<span style="color:#f92672">.</span>Values<span style="color:#f92672">.</span>Length
</code></pre></div><p>Then I setup some test data. I typically am working with small arrays so I&rsquo;m just going to be summing up the values from <code>1.0</code> to <code>100.0</code> and I&rsquo;ll perform that <code>100,000</code> times. I create my three different types for my testing.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> iterations <span style="color:#f92672">=</span> 100_000
<span style="color:#66d9ef">let</span> numberCount <span style="color:#f92672">=</span> 100

<span style="color:#66d9ef">let</span> rawArray <span style="color:#f92672">=</span> <span style="color:#f92672">[|</span>1<span style="color:#f92672">.</span>0 <span style="color:#f92672">..</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">float</span> numberCount<span style="color:#f92672">)|]</span>

<span style="color:#66d9ef">let</span> classWrapper <span style="color:#f92672">=</span>
   <span style="color:#f92672">[|</span>1<span style="color:#f92672">.</span>0 <span style="color:#f92672">..</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">float</span> numberCount<span style="color:#f92672">)|]</span> 
   <span style="color:#f92672">|&gt;</span> ClassWrapper<span style="color:#f92672">&lt;</span>ItemIdx<span style="color:#f92672">,</span> <span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>

<span style="color:#66d9ef">let</span> structWrapper <span style="color:#f92672">=</span>
    <span style="color:#f92672">[|</span>1<span style="color:#f92672">.</span>0 <span style="color:#f92672">..</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">float</span> numberCount<span style="color:#f92672">)|]</span> 
    <span style="color:#f92672">|&gt;</span> StructWrapper<span style="color:#f92672">&lt;</span>ItemIdx<span style="color:#f92672">,</span> <span style="color:#f92672">_&gt;</span>
</code></pre></div><p>Alright, data prepared, time to create some tests. I open the namespaces I need from BenchmarkDotNet and create my <code>Benchmark</code> class. I create three tests to see which approach is faster. I’m assuming that the raw array is the absolute limit (short of SIMD).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Benchmarks</span> () <span style="color:#f92672">=</span>

    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">RawArray</span> () <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">let</span> mutable iterationIdx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span>0

        <span style="color:#66d9ef">while</span> iterationIdx <span style="color:#f92672">&lt;</span> iterations <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
            <span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> rawArray<span style="color:#f92672">.</span>Length
            <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> len <span style="color:#66d9ef">do</span>
                result <span style="color:#f92672">&lt;-</span> result <span style="color:#f92672">+</span> rawArray<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span>
                idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1
                
            result <span style="color:#f92672">&lt;-</span> 0<span style="color:#f92672">.</span>0 <span style="color:#75715e">// Reset
</span><span style="color:#75715e"></span>            iterationIdx <span style="color:#f92672">&lt;-</span> iterationIdx <span style="color:#f92672">+</span> 1

        result


    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">ClassWrapper</span> () <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">let</span> mutable iterationIdx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span>0

        <span style="color:#66d9ef">while</span> iterationIdx <span style="color:#f92672">&lt;</span> iterations <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0<span style="color:#f92672">&lt;</span>ItemIdx<span style="color:#f92672">&gt;</span>
            <span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> classWrapper<span style="color:#f92672">.</span>Length
            <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> len <span style="color:#66d9ef">do</span>
                result <span style="color:#f92672">&lt;-</span> result <span style="color:#f92672">+</span> classWrapper<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span>
                idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1<span style="color:#f92672">&lt;</span>ItemIdx<span style="color:#f92672">&gt;</span>
                
            result <span style="color:#f92672">&lt;-</span> 0<span style="color:#f92672">.</span>0 <span style="color:#75715e">// Reset
</span><span style="color:#75715e"></span>            iterationIdx <span style="color:#f92672">&lt;-</span> iterationIdx <span style="color:#f92672">+</span> 1

        result


    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">StructWrapper</span> () <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">let</span> mutable iterationIdx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span>0

        <span style="color:#66d9ef">while</span> iterationIdx <span style="color:#f92672">&lt;</span> iterations <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0<span style="color:#f92672">&lt;</span>ItemIdx<span style="color:#f92672">&gt;</span>
            <span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> structWrapper<span style="color:#f92672">.</span>Length
            <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> len <span style="color:#66d9ef">do</span>
                result <span style="color:#f92672">&lt;-</span> result <span style="color:#f92672">+</span> structWrapper<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span>
                idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1<span style="color:#f92672">&lt;</span>ItemIdx<span style="color:#f92672">&gt;</span>
                
            result <span style="color:#f92672">&lt;-</span> 0<span style="color:#f92672">.</span>0 <span style="color:#75715e">// Reset
</span><span style="color:#75715e"></span>            iterationIdx <span style="color:#f92672">&lt;-</span> iterationIdx <span style="color:#f92672">+</span> 1

        result
</code></pre></div><p>I run the benchmarks and get an unexpected result.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>RawArray</td>
<td style="text-align:right">6.434 ms</td>
<td style="text-align:right">0.1241 ms</td>
<td style="text-align:right">0.1100 ms</td>
</tr>
<tr>
<td>ClassWrapper</td>
<td style="text-align:right">6.969 ms</td>
<td style="text-align:right">0.1177 ms</td>
<td style="text-align:right">0.1101 ms</td>
</tr>
<tr>
<td>StructWrapper</td>
<td style="text-align:right">23.983 ms</td>
<td style="text-align:right">0.2800 ms</td>
<td style="text-align:right">0.2619 ms</td>
</tr>
</tbody>
</table>
<p>I am shocked that the <code>StructWrapper</code> performed so much more poorly that either the <code>RawArray</code> or <code>ClassWrapper</code>. This does not make any sense to me. If anything, <code>StructWrapper</code> should be faster than <code>ClassWrapper</code> but these numbers aren&rsquo;t lying. The .NET Runtime has some special optimizations it can perform for Struct. In .NET 6.0 this includes keeping the values of the struct in the registers. You can check out the work <a href="https://github.com/dotnet/runtime/issues/43867">here</a></p>
<h2 id="the-fix">The Fix<a hidden class="anchor" aria-hidden="true" href="#the-fix">#</a></h2>
<p>I go to StackOverflow and Twitter to see if anyone had insight into what is going on. Upon the recommendation of <a href="https://twitter.com/_cartermp">Phillip Carter</a> I move the code for generating the test data to inside the <code>Benchmark</code> class. When I do this, I get these results.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>InternalRawArray</td>
<td style="text-align:right">5.788 ms</td>
<td style="text-align:right">0.0241 ms</td>
<td style="text-align:right">0.0225 ms</td>
</tr>
<tr>
<td>InternalClassWrapper</td>
<td style="text-align:right">5.983 ms</td>
<td style="text-align:right">0.0174 ms</td>
<td style="text-align:right">0.0154 ms</td>
</tr>
<tr>
<td>InternalStructWrapper</td>
<td style="text-align:right">5.980 ms</td>
<td style="text-align:right">0.0423 ms</td>
<td style="text-align:right">0.0396 ms</td>
</tr>
</tbody>
</table>
<p>Now the performance is roughly equivalent. Apparently, there are some gotchas with the BenchmarkDotNet library and F# modules. I go ahead and define some additional types for wrapping an <code>array</code>. I wrap an <code>array</code> using a Record and a Record with the <code>[&lt;Struct&gt;]</code> attribute. I create tests where the data is defined inside the <code>Benchmark</code> class and tests where the data is defined in a separate module. Here is what I ended up finding.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>InternalRawArray</td>
<td style="text-align:right">5.839 ms</td>
<td style="text-align:right">0.0517 ms</td>
<td style="text-align:right">0.0431 ms</td>
</tr>
<tr>
<td>ExternalRawArray</td>
<td style="text-align:right">6.537 ms</td>
<td style="text-align:right">0.0429 ms</td>
<td style="text-align:right">0.0401 ms</td>
</tr>
<tr>
<td>InternalClassWrapper</td>
<td style="text-align:right">5.866 ms</td>
<td style="text-align:right">0.0183 ms</td>
<td style="text-align:right">0.0203 ms</td>
</tr>
<tr>
<td>ExternalClassWrapper</td>
<td style="text-align:right">6.903 ms</td>
<td style="text-align:right">0.0734 ms</td>
<td style="text-align:right">0.0686 ms</td>
</tr>
<tr>
<td>InternalStructWrapper</td>
<td style="text-align:right">6.032 ms</td>
<td style="text-align:right">0.0933 ms</td>
<td style="text-align:right">0.0827 ms</td>
</tr>
<tr>
<td>ExternalStructWrapper</td>
<td style="text-align:right">21.042 ms</td>
<td style="text-align:right">0.0932 ms</td>
<td style="text-align:right">0.0826 ms</td>
</tr>
<tr>
<td>InternalRecordApproach</td>
<td style="text-align:right">5.920 ms</td>
<td style="text-align:right">0.0728 ms</td>
<td style="text-align:right">0.0608 ms</td>
</tr>
<tr>
<td>ExternalRecordApproach</td>
<td style="text-align:right">6.899 ms</td>
<td style="text-align:right">0.0760 ms</td>
<td style="text-align:right">0.0674 ms</td>
</tr>
<tr>
<td>InternalStructRecordApproach</td>
<td style="text-align:right">5.899 ms</td>
<td style="text-align:right">0.0947 ms</td>
<td style="text-align:right">0.1297 ms</td>
</tr>
<tr>
<td>ExternalStructRecordApproach</td>
<td style="text-align:right">5.841 ms</td>
<td style="text-align:right">0.0576 ms</td>
<td style="text-align:right">0.0450 ms</td>
</tr>
</tbody>
</table>
<p>As you can see, I stumbled upon what appears to be a single outlier. You can also see that across the board the tests that are operating on data defined inside the <code>Benchmark</code> class outperform those where the data is defined externally. The only exception is the Struct Record but the difference in means is withen the noise of the tests. I think it&rsquo;s important for an F# developer whose looking for performance to be aware that where data is declared can affect your benchmarks and could lead to incorrect conclusions. The guidance I received from Phillip was to declare the data in the <code>Benchmark</code> class. <a href="https://twitter.com/badamczewski01">Bartosz Adamczewski</a> recommends writing the library code in F# and the benchmarks in C#. This makes sense as I believe the BenchmarkDotNet library considers the C# use case primarily.</p>
<p>If you would like to see the full set of tests you can check out the repo <a href="https://github.com/matthewcrews/UnitsOfMeasureIndexArray">here</a>. Until next time, stay safe out there and have fun with your benchmarking!</p>

</div>
  <footer class="post-footer">



<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share BenchmarkDotNet Gotcha with F# on twitter"
        href="https://twitter.com/intent/tweet/?text=BenchmarkDotNet%20Gotcha%20with%20F%23&amp;url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f11%2fbenchmarkdotnet-gotcha%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share BenchmarkDotNet Gotcha with F# on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f11%2fbenchmarkdotnet-gotcha%2f&amp;title=BenchmarkDotNet%20Gotcha%20with%20F%23&amp;summary=BenchmarkDotNet%20Gotcha%20with%20F%23&amp;source=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f11%2fbenchmarkdotnet-gotcha%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share BenchmarkDotNet Gotcha with F# on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f11%2fbenchmarkdotnet-gotcha%2f&title=BenchmarkDotNet%20Gotcha%20with%20F%23">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share BenchmarkDotNet Gotcha with F# on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f11%2fbenchmarkdotnet-gotcha%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share BenchmarkDotNet Gotcha with F# on whatsapp"
        href="https://api.whatsapp.com/send?text=BenchmarkDotNet%20Gotcha%20with%20F%23%20-%20https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f11%2fbenchmarkdotnet-gotcha%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share BenchmarkDotNet Gotcha with F# on telegram"
        href="https://telegram.me/share/url?text=BenchmarkDotNet%20Gotcha%20with%20F%23&amp;url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f11%2fbenchmarkdotnet-gotcha%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://matthewcrews.com">Matthew Crews</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    MathJax = {
    tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
    };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</body>

</html>
