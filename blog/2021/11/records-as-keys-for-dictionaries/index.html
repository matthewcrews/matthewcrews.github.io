<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerating Dictionary Lookup with Records as Keys - Matthew Crews</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/png" href="/favicon-32x32.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">

  
  
  
  <link rel="stylesheet" href="/css/style.min.3940494e396e00ba1cd5c589c5ff2ee8b5b9c03100b6fff6944d59e8f5cc2e56.css">
  

  

  
    
    <meta property="og:title" content="Accelerating Dictionary Lookup with Records as Keys"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="/blog/2021/11/records-as-keys-for-dictionaries/"/>
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@zerostaticio"/>
    <meta name="twitter:creator" content="@zerostaticio"/>
  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-blog">
      <a href="/blog/">
        <span>Blog</span>
      </a>
    </li>
    
    <li class="menu-item-about">
      <a href="/about/">
        <span>About</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="/"><img height=36px alt="Serif - A Hugo Business Theme" src="/images/logo/logo.png" /></a>
    </div>
    <div class="logo-mobile">
      <a href="/"><img height=36px alt="Serif - A Hugo Business Theme" src="/images/logo/logo.png" /></a>
    </div>
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    
    
    <li class="menu-item-blog ">
      <a href="/blog/">
        
        <span>Blog</span>
      </a>
    </li>
    
    
    
    <li class="menu-item-about ">
      <a href="/about/">
        
        <span>About</span>
      </a>
    </li>
    
  </ul>
</div>

    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button" aria-label="Mobile Menu">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>

    
<div class="container pb-6 pt-6 pt-md-10 pb-md-10">
  <div class="row justify-content-start">
    <div class="col-12 col-md-8">
      <h1 class="title">Accelerating Dictionary Lookup with Records as Keys</h1>
      <div class="content"><blockquote>
<p><strong>NOTE</strong>: All the code can be found <a href="https://github.com/matthewcrews/RecordsAsKeysForDictionary">here</a>. Feel free to follow along!</p>
</blockquote>
<h2 id="the-problem">The Problem</h2>
<p>I ran into an interesting problem a week ago and I think others may find some value in it. I am currently working on writing a small Discrete-Event Simulation engine for a manufacturing facility. This problem required a bespoke solution since the current products that are available on the market are built with Modelers in mind and not deployment. In our ideal scenario this engine gets embedded in a decision-making product that is run by a Plant Manager.</p>
<p>The goal is to take a Discrete-Event model of the facility and then wrap it in an optimization loop to find the best possible schedule for the facility. For optimization to be effective, you need to be able to run the model as fast as possible. At each time step we need to evaluate how the processes in the facility are going to respond to the updated state. Let&rsquo;s call this evaluation <code>CalculateChange</code>. The input for the <code>CalculateChange</code> is a type called <code>Settings</code>. <code>Settings</code> holds the parameters for the pieces of equipment in the facility. The result of calling <code>CalculateChange</code> will be a <code>Changes</code> type which holds the changes we will make to the model.</p>
<p>In our case, for a given <code>Settings</code> we will always get the same <code>Changes</code> back from <code>CalculateChange</code>. This means that <code>CalculateChange</code> is a natural candidate for <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>. The easiest way to memoize a function, that I am aware of, is to store results in a <code>Dictionary</code> and check to see if a result is already stored in it. A silly example of memoization is the following.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#75715e">// Create a Dictionary to hold our results
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> cache <span style="color:#f92672">=</span> Dictionary ()

<span style="color:#66d9ef">let</span> memoizedFunction <span style="color:#f92672">(</span>a<span style="color:#f92672">:</span> int<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>

    <span style="color:#66d9ef">match</span> cache<span style="color:#f92672">.</span>TryFindValue a <span style="color:#66d9ef">with</span>
    <span style="color:#f92672">|</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">,</span> result <span style="color:#f92672">-&gt;</span>
        <span style="color:#75715e">// Yay, the result for `a` was in our cache
</span><span style="color:#75715e"></span>        result
    <span style="color:#f92672">|</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">,</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span>
        <span style="color:#75715e">// Booooo! The result was not in our cache :/
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Now we have to call the expensive function
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> reallyExpensiveFunctionToCall a
        <span style="color:#75715e">// We store the result so that it will be in the cache next time
</span><span style="color:#75715e"></span>        cache<span style="color:#f92672">.[</span>a<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;-</span> result
        <span style="color:#75715e">// Now return the result
</span><span style="color:#75715e"></span>        result

</code></pre></div><p>Here we are trying to keep from having to evaluate <code>reallyExpensiveFunctionToCall</code> each time by storing the result. Memoization can be a powerful way to speed up your programs. You are trading memory footprint for speed. This means this technique should only be used in an environment where you have plenty of memory available and what you really need is speed.</p>
<h2 id="the-challenge">The Challenge</h2>
<p>This is where things take an interesting turn. Our <code>Settings</code> type is made up of a few arrays. Two of them are <code>array&lt;float&gt;</code> and one of them is an <code>array&lt;BufferState&gt;</code>. <code>BufferState</code> is a <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/discriminated-unions">Discriminated Union</a> with 3 cases: <code>Full</code>, <code>Partial</code>, and <code>Empty</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BufferState</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> Full
    <span style="color:#f92672">|</span> Partial
    <span style="color:#f92672">|</span> Empty

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Settings</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">{</span>
        Levels <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
        MaxRates <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
        Buffers <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span>BufferState<span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>I am wanting to use the <code>Settings</code> type as a Key in a Dictionary. Now, some of you may already have alarms going off in your head. We are wanting to hash and check equality of something that has <code>float</code> in it. If you ask a question about this on StackOverflow, the first responses will typically be people telling you not to do that. I will echo their caution but add some context about when it is okay.</p>
<p>Equality of any floating-point number is a notoriously difficult problem. Floating point math has rounding error built in which means that something that works mathematically may not work computationally. For example. Try putting this into an F# Interactive session and you will get false.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#75715e">// This will return FALSE
</span><span style="color:#75715e"></span>0<span style="color:#f92672">.</span>1 <span style="color:#f92672">+</span> 0<span style="color:#f92672">.</span>2 <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span>3
</code></pre></div><p>If you were taking a math class, the answer would be true, obviously. Using floating point math though <code>0.3</code> cannot be perfectly represented so what you get it when you put in <code>0.3</code> is</p>
<pre tabindex="0"><code>0.299999999999999988897769753748434595763683319091796875
</code></pre><p>Likewise, when you add <code>0.1</code> and <code>0.2</code> together you get</p>
<pre tabindex="0"><code>0.3000000000000000444089209850062616169452667236328125000
</code></pre><p>Those two numbers are very, very close but they are technically not the same. Okay, so I agree with the StackOverflow mob that testing equality of floats is fraught with danger. There are situations where it IS okay though. Those situations are when you are needing to compare <code>float</code> values that no math has been performed on. In my use case, the values in <code>Settings</code> are parameters that are being set on the condition of other parts of the facility. They are not the result of any computation. This means that I can reliably test their equality because no math has been performed on them.</p>
<blockquote>
<p><strong>Note</strong>: I highly recommend reading the paper <a href="https://www.itu.dk/~sestoft/bachelor/IEEE754_article.pdf">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a> by David Goldberg. It&rsquo;s probably way more detail than you need at this time but if you are working with floating-point math it&rsquo;s worth your time.</p>
</blockquote>
<p>What is nice is that F# is going to give us structural equality for free. This means using <code>Settings</code> as a key for a record should be no problem, right? Well, as with everything the answer is, &ldquo;It depends&hellip;&rdquo;. Earlier this year, Isaac Abraham wrote a <a href="https://www.compositional-it.com/news-blog/custom-equality-and-comparison-in-f/">great blog post</a> for Compositional IT which went into the performance gains that can be had from writing custom equality and comparison in F#. I highly recommend you go read that article first before continuing.</p>
<p>In that article Isaac showed that there can be significant speed gains from implementing your own equality on a Record. In his tests the speed up for a Dictionary lookup was anywhere from 2 to 3 times faster. That has significant implications on the runtime of your algorithm if there is a Dictionary lookup in the heart of an inner loop. In my use case I want to lookup results in a Dictionary at every single time step of the simulation because a Dictionary lookup is still several orders of magnitude cheaper than running the expensive calculation logic.</p>
<p>Before we go doing anything though, let&rsquo;s establish the baseline of our performance so we don&rsquo;t flail around blindly. For this domain the values of <code>Levels</code> field can range from <code>0.0</code> to <code>100.0</code> and it can contain anywhere from 10 to 100 values. The values in <code>MaxRates</code> range from <code>0.0</code> to <code>10.0</code> and contain anywhere from 10 to 100 values. The values of the <code>Buffers</code> field are evenly distributed between the three possible states of <code>BufferState</code> and can be from 10 to 100 values. We&rsquo;ll need to generate some data for us to test on.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">open</span> System

<span style="color:#75715e">// Parameters for generating test data
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> rng <span style="color:#f92672">=</span> Random <span style="color:#f92672">(</span>123<span style="color:#f92672">)</span>
<span style="color:#66d9ef">let</span> maxLevelValue <span style="color:#f92672">=</span> 100<span style="color:#f92672">.</span>0
<span style="color:#66d9ef">let</span> maxRateValue <span style="color:#f92672">=</span> 100<span style="color:#f92672">.</span>0
<span style="color:#75715e">// How many lookups we will perform in our test
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> lookupCount <span style="color:#f92672">=</span> 10_000

<span style="color:#75715e">// Maximum length of the arrays
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> maxLevelsLength <span style="color:#f92672">=</span> 100
<span style="color:#66d9ef">let</span> maxRatesLength <span style="color:#f92672">=</span> 100
<span style="color:#66d9ef">let</span> maxBufferStateLength <span style="color:#f92672">=</span> 100

<span style="color:#75715e">// How many arrays to generate
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> levelsCount  <span style="color:#f92672">=</span> 1_000
<span style="color:#66d9ef">let</span> maxRatesCount <span style="color:#f92672">=</span> 1_000
<span style="color:#66d9ef">let</span> buffersCount <span style="color:#f92672">=</span> 1_000

<span style="color:#75715e">// How many different random Settings to generate
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> randomSettingsCount <span style="color:#f92672">=</span> 1_000


<span style="color:#75715e">// Function to create an array&lt;float&gt; with random values
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> randomFloatArray <span style="color:#f92672">(</span>rng<span style="color:#f92672">:</span> Random<span style="color:#f92672">)</span> maxValue length <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> Array.zeroCreate length

    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> 0 <span style="color:#66d9ef">to</span> result<span style="color:#f92672">.</span>Length <span style="color:#f92672">-</span> 1 <span style="color:#66d9ef">do</span>
        result<span style="color:#f92672">.[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;-</span> maxValue <span style="color:#f92672">*</span> <span style="color:#f92672">(</span>rng<span style="color:#f92672">.</span>NextDouble ()<span style="color:#f92672">)</span>

    result


<span style="color:#75715e">// Function to create an array&lt;BufferState&gt; with random values
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> randomBufferStateArray <span style="color:#f92672">(</span>rng<span style="color:#f92672">:</span> Random<span style="color:#f92672">)</span> maxValue length <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> Array.zeroCreate length

    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> 0 <span style="color:#66d9ef">to</span> result<span style="color:#f92672">.</span>Length <span style="color:#f92672">-</span> 1 <span style="color:#66d9ef">do</span>
        <span style="color:#75715e">// The `Next` method is generating values from 0 to 2
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// The MaxValue arg used here is exclusive
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">match</span> rng<span style="color:#f92672">.</span>Next 3 <span style="color:#66d9ef">with</span>
        <span style="color:#f92672">|</span> 0 <span style="color:#f92672">-&gt;</span> result<span style="color:#f92672">.[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;-</span> BufferState.Empty
        <span style="color:#f92672">|</span> 1 <span style="color:#f92672">-&gt;</span> result<span style="color:#f92672">.[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;-</span> BufferState.Full
        <span style="color:#f92672">|</span> 2 <span style="color:#f92672">-&gt;</span> result<span style="color:#f92672">.[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;-</span> BufferState.Partial
        <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> failwith <span style="color:#e6db74">&#34;Really?&#34;</span>

    result

<span style="color:#75715e">// Generate possible array&lt;float&gt; to be used as the Levels field
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> levels <span style="color:#f92672">=</span>
    seq <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">_</span> <span style="color:#66d9ef">in</span> 1 <span style="color:#f92672">..</span> levelsCount <span style="color:#f92672">-&gt;</span>
            <span style="color:#f92672">((</span>rng<span style="color:#f92672">.</span>Next maxLevelsLength<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#75715e">// Generate a random length
</span><span style="color:#75715e"></span>            <span style="color:#f92672">|&gt;</span> randomFloatArray rng maxLevelValue
    <span style="color:#f92672">}</span> <span style="color:#f92672">|&gt;</span> Array.ofSeq

<span style="color:#75715e">// Generate possible array&lt;float&gt; to be used as the MaxRates field
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> maxRates <span style="color:#f92672">=</span>
    seq <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">_</span> <span style="color:#66d9ef">in</span> 1 <span style="color:#f92672">..</span> maxRatesCount <span style="color:#f92672">-&gt;</span>
            <span style="color:#f92672">((</span>rng<span style="color:#f92672">.</span>Next maxRatesLength<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#75715e">// Generate a random length
</span><span style="color:#75715e"></span>            <span style="color:#f92672">|&gt;</span> randomFloatArray rng maxRateValue
    <span style="color:#f92672">}</span> <span style="color:#f92672">|&gt;</span> Array.ofSeq

<span style="color:#75715e">// Generate possible array&lt;BufferState&gt; to be used as the BufferStates field
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> bufferStates <span style="color:#f92672">=</span>
    seq <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">_</span> <span style="color:#66d9ef">in</span> 1 <span style="color:#f92672">..</span> bufferStatesCount <span style="color:#f92672">-&gt;</span>
            <span style="color:#f92672">((</span>rng<span style="color:#f92672">.</span>Next maxRatesLength<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span>
            <span style="color:#f92672">|&gt;</span> randomBufferStateArray rng
    <span style="color:#f92672">}</span> <span style="color:#f92672">|&gt;</span> Array.ofSeq
</code></pre></div><p>Now we have some random data that we want to sample from to generate our random <code>Settings</code> type which we will use for lookup. The way we will do this is by creating a set of indices that we will use to lookup values for <code>Levels</code>, <code>MaxRates</code>, and <code>BufferStates</code>. The reason we want to do this is because we are going to create alternatives to the <code>Settings</code> type and we want to be sure those alternatives are populated with the same data. If it doesn&rsquo;t make sense now, it will in a few minutes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#75715e">// We want to make sure that all of our versions of the Settings type
</span><span style="color:#75715e">// have the same underlying data to hash and compare. This means we
</span><span style="color:#75715e">// need to compute the indices for the underlying data and use them
</span><span style="color:#75715e">// for all the versions of the Settings type we create.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> valueIndexes <span style="color:#f92672">=</span>
    seq <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">_</span> <span style="color:#66d9ef">in</span> 1 <span style="color:#f92672">..</span> randomSettingsCount <span style="color:#f92672">-&gt;</span>
        <span style="color:#f92672">{|</span>
            LevelsIdx <span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>Next <span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> levels<span style="color:#f92672">.</span>Length<span style="color:#f92672">)</span>
            MaxRatesIdx <span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>Next <span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> maxRates<span style="color:#f92672">.</span>Length<span style="color:#f92672">)</span>
            BufferStatesIdx <span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>Next <span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> buffers<span style="color:#f92672">.</span>Length<span style="color:#f92672">)</span>
        <span style="color:#f92672">|}</span>
    <span style="color:#f92672">}</span> <span style="color:#f92672">|&gt;</span> Array.ofSeq
    
<span style="color:#75715e">// We now generate the random Settings we will be using
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> settings <span style="color:#f92672">=</span>
    seq <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> vi <span style="color:#66d9ef">in</span> valueIndexes <span style="color:#f92672">-&gt;</span>
        <span style="color:#f92672">{</span>
            Levels <span style="color:#f92672">=</span> levels<span style="color:#f92672">[</span>vi<span style="color:#f92672">.</span>LevelsIdx<span style="color:#f92672">]</span>
            MaxRates <span style="color:#f92672">=</span> maxRates<span style="color:#f92672">[</span>vi<span style="color:#f92672">.</span>MaxRatesIdx<span style="color:#f92672">]</span>
            Buffers <span style="color:#f92672">=</span> buffers<span style="color:#f92672">[</span>vi<span style="color:#f92672">.</span>BufferStatesIdx<span style="color:#f92672">]</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span> <span style="color:#f92672">|&gt;</span> Array.ofSeq
</code></pre></div><p>Now let&rsquo;s generate a set of indices which we will use to select the <code>Settings</code> values we will look up in our performance test. Again, we are generating the indices then creating another array which holds the <code>Settings</code> values we will look up so that we can use the indices to generate the exact same list when we create alternative <code>Settings</code> types.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#75715e">// These will be the indices for deciding which Settings values we
</span><span style="color:#75715e">// will look up in each of the dictionary. We want to ensure we are
</span><span style="color:#75715e">// looking up equivalent data in all the tests.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> testIndexes <span style="color:#f92672">=</span>
    seq <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">_</span> <span style="color:#66d9ef">in</span> 1 <span style="color:#f92672">..</span> lookupCount <span style="color:#f92672">-&gt;</span>
            rng<span style="color:#f92672">.</span>Next <span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> randomSettingsCount<span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span> <span style="color:#f92672">|&gt;</span> Array.ofSeq

<span style="color:#75715e">// The values we will test looking up in a Dictionary
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> settingsKeys <span style="color:#f92672">=</span>
    testIndexes
    <span style="color:#f92672">|&gt;</span> Array.map <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> idx <span style="color:#f92672">-&gt;</span> settings<span style="color:#f92672">.[</span>idx<span style="color:#f92672">])</span>
</code></pre></div><p>Alright! We have our random <code>Settings</code> and we have the lookups we want to test. We&rsquo;ll now put our random <code>Settings</code> values into a <code>Dictionary&lt;Settings, int&gt;</code> to test looking up values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#75715e">// Create the dictionary for looking up Settings
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> settingsDictionary <span style="color:#f92672">=</span>
    settings
    <span style="color:#f92672">|&gt;</span> Array.mapi <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> i settings <span style="color:#f92672">-&gt;</span> KeyValuePair <span style="color:#f92672">(</span>settings<span style="color:#f92672">,</span> i<span style="color:#f92672">))</span>
    <span style="color:#f92672">|&gt;</span> Dictionary
</code></pre></div><p>We can now create our test. We will be using <a href="https://github.com/dotnet/BenchmarkDotNet">benchmarkDotNet</a> for our performance testing. BenchmarkDotNet has us create a class and annotate methods with the <code>[&lt;Benchmark&gt;]</code> attribute so that the performance analyzer knows what code to test. Let&rsquo;s open the necessary namespaces and write a test for our default <code>Settings</code> type.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">open</span> BenchmarkDotNet.Attributes
<span style="color:#66d9ef">open</span> BenchmarkDotNet.Running

<span style="color:#75715e">// Type to contain our performance tests
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Benchmarks</span> () <span style="color:#f92672">=</span>

    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">Default</span> () <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> 0

        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> settingsKeys<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> testKey <span style="color:#f92672">=</span> settingsKeys<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span>
            result <span style="color:#f92672">&lt;-</span> settingsDictionary<span style="color:#f92672">[</span>testKey<span style="color:#f92672">]</span>

            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1

        result
</code></pre></div><p>We then build our project by opening a terminal in the directory that holds our <code>.fsproj</code> file and build the project with the <code>Release</code> configuration.</p>
<pre tabindex="0"><code class="language-terminal" data-lang="terminal">dotnet build -c Release
</code></pre><p>This will create a release build of our code in the directory <code>&lt;Project Root&gt;/bin/Release/net6.0</code>. I open a terminal in this directory and run the <code>.exe</code> that was generated and get the following table as the result.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td style="text-align:right">36.73 ms</td>
<td style="text-align:right">0.472 ms</td>
<td style="text-align:right">0.442 ms</td>
</tr>
</tbody>
</table>
<p>This means that it is taking us 36.73 ms on average to look up our <code>Settings</code> type in the Dictionary 1,000 times. We now have a performance baseline.</p>
<h2 id="simple-override">Simple Override</h2>
<p>Let&rsquo;s do the next, obvious thing and try defining a new version of <code>Settings</code> in a new module called <code>Simple</code> where we will use the easiest means of overriding the default equality behavior. I am going to put this new type and its data in a separate module to isolate it to prevent type collision headaches.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">module</span> Simple <span style="color:#f92672">=</span>

    <span style="color:#f92672">[&lt;</span>CustomEquality<span style="color:#f92672">;</span> NoComparison<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Settings</span> <span style="color:#f92672">=</span>
        <span style="color:#f92672">{</span>
            Levels <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
            MaxRates <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
            Buffers <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span>BufferState<span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">override</span> this.<span style="color:#a6e22e">Equals</span> b <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">match</span> b <span style="color:#66d9ef">with</span>
            <span style="color:#f92672">|</span> <span style="color:#f92672">:?</span> Settings <span style="color:#66d9ef">as</span> other <span style="color:#f92672">-&gt;</span>
                this<span style="color:#f92672">.</span>Levels <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span>Levels
                <span style="color:#f92672">&amp;&amp;</span> this<span style="color:#f92672">.</span>MaxRates <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span>MaxRates
                <span style="color:#f92672">&amp;&amp;</span> this<span style="color:#f92672">.</span>Buffers <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span>Buffers
            <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">false</span>
            
        <span style="color:#66d9ef">override</span> this.<span style="color:#a6e22e">GetHashCode</span> () <span style="color:#f92672">=</span>
            hash <span style="color:#f92672">(</span>this<span style="color:#f92672">.</span>Levels<span style="color:#f92672">,</span> this<span style="color:#f92672">.</span>MaxRates<span style="color:#f92672">,</span> this<span style="color:#f92672">.</span>Buffers<span style="color:#f92672">)</span>
</code></pre></div><p>Nothing exotic going on here. We&rsquo;ve added the attributes <code>[&lt;CustomEquality&gt;]</code> and <code>[&lt;NoComparison&gt;]</code>. <code>[&lt;CustomEquality&gt;]</code> is telling the F# compiler that we are going to provide our own overloads for <code>Equals</code> and <code>GetHashCode</code>. We have to also add <code>[&lt;NoComparison&gt;]</code> because the compiler wants us to also define the necessary methods for performing comparisons. We aren&rsquo;t testing that right now, so we are telling the compiler, &ldquo;I don&rsquo;t want to define comparison so just don&rsquo;t allow me to compare it.&rdquo; This is one of the downsides of overriding default behavior. Now that we&rsquo;ve told the compiler we are defining equality, we have taken on more responsibility for how this type behaves.</p>
<p>Let&rsquo;s generate the necessary test data and update our <code>Benchmark</code> class with a new testing method. I just copy and paste the code that we used for the default <code>Settings</code> type into the module where we defined our new <code>Settings</code> with overrides.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">module</span> Simple <span style="color:#f92672">=</span>

    <span style="color:#75715e">// Type definition here...
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// This is why we defined that array of indices before. So we could generate new Settings types
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// that were populated with the same data.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// We now generate the random Settings which uses our custom overrides
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> settings <span style="color:#f92672">=</span>
        seq <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> vi <span style="color:#66d9ef">in</span> valueIndexes <span style="color:#f92672">-&gt;</span>
            <span style="color:#f92672">{</span>
                Levels <span style="color:#f92672">=</span> levels<span style="color:#f92672">[</span>vi<span style="color:#f92672">.</span>LevelsIdx<span style="color:#f92672">]</span>
                MaxRates <span style="color:#f92672">=</span> maxRates<span style="color:#f92672">[</span>vi<span style="color:#f92672">.</span>MaxRatesIdx<span style="color:#f92672">]</span>
                Buffers <span style="color:#f92672">=</span> buffers<span style="color:#f92672">[</span>vi<span style="color:#f92672">.</span>BufferStatesIdx<span style="color:#f92672">]</span>
            <span style="color:#f92672">}</span> <span style="color:#75715e">// Making sure we are getting the type we want
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span> <span style="color:#f92672">|&gt;</span> Array.ofSeq
    
    <span style="color:#75715e">// The values we will test looking up in a Dictionary
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> settings <span style="color:#f92672">=</span>
        testIndexes
        <span style="color:#f92672">|&gt;</span> Array.map <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> idx <span style="color:#f92672">-&gt;</span> settings<span style="color:#f92672">[</span>idx<span style="color:#f92672">])</span>
        
    <span style="color:#75715e">// Create the dictionary for looking up Settings
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> settingsDictionary <span style="color:#f92672">=</span>
        settings
        <span style="color:#f92672">|&gt;</span> Array.mapi <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> i settings <span style="color:#f92672">-&gt;</span> KeyValuePair <span style="color:#f92672">(</span>settings<span style="color:#f92672">,</span> i<span style="color:#f92672">))</span>
        <span style="color:#f92672">|&gt;</span> Dictionary
</code></pre></div><p>And now we add our test to the <code>Benchmarks</code> class. We also moved the default <code>Settings</code> into a module of its own so now we need to prefix the initial test with <code>Default</code>.  Our <code>Benchmark</code> class will now look like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#75715e">// Type to contain our performance tests
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Benchmarks</span> () <span style="color:#f92672">=</span>

    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">Default</span> () <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> 0

        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> Default.settingsKeys<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> testKey <span style="color:#f92672">=</span> Default.settingsKeys<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span>
            result <span style="color:#f92672">&lt;-</span> Default.settingsDictionary<span style="color:#f92672">[</span>testKey<span style="color:#f92672">]</span>

            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1

        result
        
    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">Simple</span> () <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> 0

        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> Simple.settingsKeys<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> testKey <span style="color:#f92672">=</span> Simple.settingsKeys<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span>
            result <span style="color:#f92672">&lt;-</span> Simple.settingsDictionary<span style="color:#f92672">[</span>testKey<span style="color:#f92672">]</span>

            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1

        result
</code></pre></div><p>We do another build and re-run our benchmarks. Upon completion we get these results.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td style="text-align:right">37.69 ms</td>
<td style="text-align:right">0.428 ms</td>
<td style="text-align:right">0.357 ms</td>
</tr>
<tr>
<td>Simple</td>
<td style="text-align:right">37.82 ms</td>
<td style="text-align:right">0.271 ms</td>
<td style="text-align:right">0.241 ms</td>
</tr>
</tbody>
</table>
<p>This is wildly disappointing. This had no affect which honestly, is probably a good thing. What we just implemented is essentially the default behavior of F# so we shouldn&rsquo;t expect a big change. At this point though, I got curious as to how exactly is F# generating hash codes for <code>array&lt;float&gt;</code>. I went digging into the F# source and found my way to the <a href="https://github.com/dotnet/fsharp/blob/main/src/fsharp/FSharp.Core/prim-types.fs">prim-types.fs</a> file. One thing I notice in my sleuthing is that F# has some specialized functions for generating hashcodes for <code>array&lt;int&gt;</code>, <code>array&lt;int64&gt;</code>, and <code>array&lt;byte&gt;</code> but I didn&rsquo;t see any for <code>array&lt;float&gt;</code>. Hmm, what if we created one and used that for generating our hashcodes?</p>
<h2 id="hashcode-for-arrayfloat">HashCode for <code>array&lt;float&gt;</code></h2>
<p>I decided to <del>steal</del> borrow the function that F# is using for combining hashcodes found <a href="https://github.com/dotnet/fsharp/blob/dc81e22205550f0cedf4295b06c3a1e338c1cfa1/src/fsharp/FSharp.Core/prim-types.fs#L1625">here</a>. I also copy and paste the specialized function for hashing <code>array&lt;int&gt;</code> found <a href="https://github.com/dotnet/fsharp/blob/dc81e22205550f0cedf4295b06c3a1e338c1cfa1/src/fsharp/FSharp.Core/prim-types.fs#L1650">here</a> and change it up a little to work with <code>array&lt;float&gt;</code>. I put this new functions into a new module <code>FloatHash</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">module</span> FloatHash <span style="color:#f92672">=</span>

    <span style="color:#75715e">// Source: https://github.com/dotnet/fsharp/blob/dc81e22205550f0cedf4295b06c3a1e338c1cfa1/src/fsharp/FSharp.Core/prim-types.fs#L1625
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> inline HashCombine nr x y <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">&lt;&lt;&lt;</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> y <span style="color:#f92672">+</span> 631 <span style="color:#f92672">*</span> nr

    <span style="color:#66d9ef">let</span> HashFloatArray <span style="color:#f92672">(</span>x<span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;)</span> <span style="color:#f92672">:</span> int <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> x<span style="color:#f92672">.</span>Length
            <span style="color:#66d9ef">let</span> mutable i <span style="color:#f92672">=</span> len <span style="color:#f92672">-</span> 1 
            <span style="color:#66d9ef">let</span> mutable acc <span style="color:#f92672">=</span> 0
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">do</span> 
                acc <span style="color:#f92672">&lt;-</span> HashCombine i acc <span style="color:#f92672">(</span>int x<span style="color:#f92672">.[</span>i<span style="color:#f92672">])</span>
                i <span style="color:#f92672">&lt;-</span> i <span style="color:#f92672">-</span> 1
            acc
</code></pre></div><p>Now we have the ingredients to make our own hashing function for our <code>Settings</code> type. Let&rsquo;s define a new <code>Settings</code> using this new functionality.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">module</span> FloatHash <span style="color:#f92672">=</span>
          
    <span style="color:#75715e">// ...new functions here
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">[&lt;</span>CustomEquality<span style="color:#f92672">;</span> NoComparison<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Settings</span> <span style="color:#f92672">=</span>
        <span style="color:#f92672">{</span>
            Levels <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
            MaxRates <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
            Buffers <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span>BufferState<span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">override</span> this.<span style="color:#a6e22e">Equals</span> b <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">match</span> b <span style="color:#66d9ef">with</span>
            <span style="color:#f92672">|</span> <span style="color:#f92672">:?</span> Settings <span style="color:#66d9ef">as</span> other <span style="color:#f92672">-&gt;</span>
                this<span style="color:#f92672">.</span>Levels <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span>Levels
                <span style="color:#f92672">&amp;&amp;</span> this<span style="color:#f92672">.</span>MaxRates <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span>MaxRates
                <span style="color:#f92672">&amp;&amp;</span> this<span style="color:#f92672">.</span>Buffers <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span>Buffers
            <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">false</span>
            
        <span style="color:#66d9ef">override</span> this.<span style="color:#a6e22e">GetHashCode</span> () <span style="color:#f92672">=</span>
            <span style="color:#75715e">// We now use our `hashFloatArray` 
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">let</span> levelsHash <span style="color:#f92672">=</span> HashFloatArray this<span style="color:#f92672">.</span>Levels
            <span style="color:#66d9ef">let</span> maxRatesHash <span style="color:#f92672">=</span> HashFloatArray this<span style="color:#f92672">.</span>MaxRates
            <span style="color:#66d9ef">let</span> buffersHash <span style="color:#f92672">=</span> this<span style="color:#f92672">.</span>Buffers<span style="color:#f92672">.</span>GetHashCode()
            hash <span style="color:#f92672">(</span>levelsHash<span style="color:#f92672">,</span> maxRatesHash<span style="color:#f92672">,</span> buffersHash<span style="color:#f92672">)</span>
</code></pre></div><p>We again copy and paste the data generating code into this new module to create our test data with our new type. We then add a third method to our <code>Benchmarks</code> class to test this new approach.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Benchmarks</span> () <span style="color:#f92672">=</span>

    <span style="color:#75715e">// Previous benchmarks are still here. I&#39;m just not posting the code for brevity
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">FloatHash</span> () <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> 0

        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> FloatHash.settingsKeys<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> testKey <span style="color:#f92672">=</span> FloatHash.settingsKeys<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span>
            result <span style="color:#f92672">&lt;-</span> FloatHash.settingsDictionary<span style="color:#f92672">[</span>testKey<span style="color:#f92672">]</span>

            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1

        result
</code></pre></div><p>After we compile and run our benchmarks, we get the following.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td style="text-align:right">37.12 ms</td>
<td style="text-align:right">0.648 ms</td>
<td style="text-align:right">0.606 ms</td>
</tr>
<tr>
<td>Simple</td>
<td style="text-align:right">36.84 ms</td>
<td style="text-align:right">0.270 ms</td>
<td style="text-align:right">0.253 ms</td>
</tr>
<tr>
<td>FloatHash</td>
<td style="text-align:right">10.12 ms</td>
<td style="text-align:right">0.093 ms</td>
<td style="text-align:right">0.087 ms</td>
</tr>
</tbody>
</table>
<p>Whoa! Now that&rsquo;s interesting. We get a significant speed up when using a function that is specifically made for a <code>array&lt;float</code>&gt;. Now we are making progress.</p>
<h2 id="faster-by-ignoring">Faster by Ignoring</h2>
<p>Now, if you are one of the few people who clicked the links to the F# source code, you may notice that the version of <code>HashFloatArray</code> I wrote isn&rsquo;t quite like the version that is in the F# source code. The F# source code only hashes up to the first 18 values. It ignores the elements after that. I&rsquo;m assuming the rationale is that the first 18 elements are sufficient for generating a unique enough hashcode. Let&rsquo;s create a new module <code>FloatHashSort</code> where we define a new <code>Settings</code> type that uses this abbreviated hashing.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">module</span> FloatHashShort <span style="color:#f92672">=</span>
    
    <span style="color:#75715e">// To limit the number of elements we use for hashing
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> defaultHashNodes <span style="color:#f92672">=</span> 18
    <span style="color:#66d9ef">let</span> inline HashCombine nr x y <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">&lt;&lt;&lt;</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> y <span style="color:#f92672">+</span> 631 <span style="color:#f92672">*</span> nr
    
    <span style="color:#66d9ef">let</span> HashFloatArray <span style="color:#f92672">(</span>x<span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;)</span> <span style="color:#f92672">:</span> int <span style="color:#f92672">=</span>
          <span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> x<span style="color:#f92672">.</span>Length
          <span style="color:#66d9ef">let</span> mutable i <span style="color:#f92672">=</span> len <span style="color:#f92672">-</span> 1
          <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;</span> defaultHashNodes <span style="color:#66d9ef">then</span> i <span style="color:#f92672">&lt;-</span> defaultHashNodes <span style="color:#75715e">// limit the hash
</span><span style="color:#75715e"></span>          <span style="color:#66d9ef">let</span> mutable acc <span style="color:#f92672">=</span> 0
          <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">do</span> 
              acc <span style="color:#f92672">&lt;-</span> HashCombine i acc <span style="color:#f92672">(</span>int x<span style="color:#f92672">.[</span>i<span style="color:#f92672">])</span>
              i <span style="color:#f92672">&lt;-</span> i <span style="color:#f92672">-</span> 1
          acc
          
    <span style="color:#f92672">[&lt;</span>CustomEquality<span style="color:#f92672">;</span> NoComparison<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Settings</span> <span style="color:#f92672">=</span>
        <span style="color:#f92672">{</span>
            Levels <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
            MaxRates <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
            Buffers <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span>BufferState<span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">override</span> this.<span style="color:#a6e22e">Equals</span> b <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">match</span> b <span style="color:#66d9ef">with</span>
            <span style="color:#f92672">|</span> <span style="color:#f92672">:?</span> Settings <span style="color:#66d9ef">as</span> other <span style="color:#f92672">-&gt;</span>
                this<span style="color:#f92672">.</span>Levels <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span>Levels
                <span style="color:#f92672">&amp;&amp;</span> this<span style="color:#f92672">.</span>MaxRates <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span>MaxRates
                <span style="color:#f92672">&amp;&amp;</span> this<span style="color:#f92672">.</span>Buffers <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span>Buffers
            <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">false</span>
            
        <span style="color:#66d9ef">override</span> this.<span style="color:#a6e22e">GetHashCode</span> () <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">let</span> levelsHash <span style="color:#f92672">=</span> HashFloatArray this<span style="color:#f92672">.</span>Levels
            <span style="color:#66d9ef">let</span> maxRatesHash <span style="color:#f92672">=</span> HashFloatArray this<span style="color:#f92672">.</span>MaxRates
            <span style="color:#66d9ef">let</span> buffersHash <span style="color:#f92672">=</span> this<span style="color:#f92672">.</span>Buffers<span style="color:#f92672">.</span>GetHashCode()
            hash <span style="color:#f92672">(</span>levelsHash<span style="color:#f92672">,</span> maxRatesHash<span style="color:#f92672">,</span> buffersHash<span style="color:#f92672">)</span>

    <span style="color:#75715e">// There is also the data creation code here but I&#39;m leaving it out because it&#39;s a repeat of
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// what you have seen already.
</span></code></pre></div><p>And we add a fourth benchmark to <code>Benchmarks</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Benchmarks</span> () <span style="color:#f92672">=</span>

    <span style="color:#75715e">// ...previous benchmarks here
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">FloatHashShort</span> () <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> 0

        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> FloatHashShort.settingsKeys<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> testKey <span style="color:#f92672">=</span> FloatHashShort.settingsKeys<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span>
            result <span style="color:#f92672">&lt;-</span> FloatHashShort.settingsDictionary<span style="color:#f92672">[</span>testKey<span style="color:#f92672">]</span>

            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1

        result
</code></pre></div><p>We recompile and run those benchmarks! Let&rsquo;s see what we get.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td style="text-align:right">35.546 ms</td>
<td style="text-align:right">0.5105 ms</td>
<td style="text-align:right">0.3985 ms</td>
</tr>
<tr>
<td>Simple</td>
<td style="text-align:right">38.245 ms</td>
<td style="text-align:right">0.3848 ms</td>
<td style="text-align:right">0.3600 ms</td>
</tr>
<tr>
<td>FloatHash</td>
<td style="text-align:right">9.861 ms</td>
<td style="text-align:right">0.0399 ms</td>
<td style="text-align:right">0.0333 ms</td>
</tr>
<tr>
<td>FloatHashShort</td>
<td style="text-align:right">9.459 ms</td>
<td style="text-align:right">0.0965 ms</td>
<td style="text-align:right">0.0903 ms</td>
</tr>
</tbody>
</table>
<p>Alright! A little more progress. Nothing crazy but we&rsquo;ll take everything we can get.</p>
<h2 id="faster-arrayfloat-equality">Faster <code>array&lt;float&gt;</code> Equality</h2>
<p>We made a little progress now on the <code>GetHashCode</code> side of our problem. Let&rsquo;s look at the Equals now. We would like to speed this up. Right now, we are using the built in functionality of F# to evaluate the equality of the arrays. Let&rsquo;s write our own to see if we get more performance.</p>
<p>We are going to write a function which is going to take two <code>array&lt;float&gt;</code> and test whether all the values are the same. We will be using a <code>while</code> loop in this case. From my understanding, all loops get compiled down to <code>while</code> loops in IL. Using a <code>while</code> will get early termination and the most compact assembly that I am aware of. For more info on optimizing .NET I refer you to Federico Andres Lois (@federicolois) and Bartosz Adamczewski (@badamczewski01). We create a new module, <code>FloatArrayEquals</code>, to hold our new approach.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">module</span> FloatArrayEquals <span style="color:#f92672">=</span>

    <span style="color:#75715e">// ...our updated hashing code is still here. Not shown for brevity
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// The function we will use to compare the values in two float arrays
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> FloatArrayEquals <span style="color:#f92672">(</span>a<span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;)</span> <span style="color:#f92672">(</span>b<span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;)</span> <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">if</span> a<span style="color:#f92672">.</span>Length <span style="color:#f92672">&lt;&gt;</span> b<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">then</span>
            invalidArg <span style="color:#f92672">(</span>nameof b<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;Cannot check equality on arrays of different lengths&#34;</span>
            
        <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
        
        <span style="color:#75715e">// Use a while loop to create better assembly
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> a<span style="color:#f92672">.</span>Length <span style="color:#f92672">&amp;&amp;</span> result <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">if</span> a<span style="color:#f92672">.[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;&gt;</span> b<span style="color:#f92672">.[</span>idx<span style="color:#f92672">]</span> <span style="color:#66d9ef">then</span>
                result <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">false</span>
                
            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1
            
        result

    <span style="color:#f92672">[&lt;</span>CustomEquality<span style="color:#f92672">;</span> NoComparison<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Settings</span> <span style="color:#f92672">=</span>
        <span style="color:#f92672">{</span>
            Levels <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
            MaxRates <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
            Buffers <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span>BufferState<span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">override</span> this.<span style="color:#a6e22e">Equals</span> b <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">match</span> b <span style="color:#66d9ef">with</span>
            <span style="color:#f92672">|</span> <span style="color:#f92672">:?</span> Settings <span style="color:#66d9ef">as</span> other <span style="color:#f92672">-&gt;</span>
                <span style="color:#75715e">// We are using our new function to compare the values
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// in our array&lt;float&gt;
</span><span style="color:#75715e"></span>                <span style="color:#f92672">(</span>FloatArrayEquals this<span style="color:#f92672">.</span>Levels other<span style="color:#f92672">.</span>Levels<span style="color:#f92672">)</span>
                <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>FloatArrayEquals this<span style="color:#f92672">.</span>MaxRates other<span style="color:#f92672">.</span>MaxRates<span style="color:#f92672">)</span>
                <span style="color:#f92672">&amp;&amp;</span> this<span style="color:#f92672">.</span>Buffers <span style="color:#f92672">=</span> other<span style="color:#f92672">.</span>Buffers
            <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">false</span>
            
        <span style="color:#66d9ef">override</span> this.<span style="color:#a6e22e">GetHashCode</span> () <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">let</span> levelsHash <span style="color:#f92672">=</span> HashFloatArray this<span style="color:#f92672">.</span>Levels
            <span style="color:#66d9ef">let</span> maxRatesHash <span style="color:#f92672">=</span> HashFloatArray this<span style="color:#f92672">.</span>MaxRates
            <span style="color:#66d9ef">let</span> buffersHash <span style="color:#f92672">=</span> this<span style="color:#f92672">.</span>Buffers<span style="color:#f92672">.</span>GetHashCode()
            hash <span style="color:#f92672">(</span>levelsHash<span style="color:#f92672">,</span> maxRatesHash<span style="color:#f92672">,</span> buffersHash<span style="color:#f92672">)</span>
</code></pre></div><p>We add a new method to <code>Benchmark</code>&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Benchmarks</span> () <span style="color:#f92672">=</span>
    <span style="color:#75715e">// Previous benchmarks are still here...
</span><span style="color:#75715e"></span>        
    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">ArrayEquals</span> () <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> 0

        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> ArrayEquals.settingsKeys<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> testKey <span style="color:#f92672">=</span> ArrayEquals.settingsKeys<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span>
            result <span style="color:#f92672">&lt;-</span> ArrayEquals.settingsDictionary<span style="color:#f92672">[</span>testKey<span style="color:#f92672">]</span>

            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1

        result
</code></pre></div><p>Then compile and run our tests to get&hellip;</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td style="text-align:right">37.085 ms</td>
<td style="text-align:right">0.1836 ms</td>
<td style="text-align:right">0.1627 ms</td>
</tr>
<tr>
<td>Simple</td>
<td style="text-align:right">35.839 ms</td>
<td style="text-align:right">0.2870 ms</td>
<td style="text-align:right">0.2544 ms</td>
</tr>
<tr>
<td>FloatHash</td>
<td style="text-align:right">10.189 ms</td>
<td style="text-align:right">0.1942 ms</td>
<td style="text-align:right">0.1907 ms</td>
</tr>
<tr>
<td>FloatHashShort</td>
<td style="text-align:right">9.454 ms</td>
<td style="text-align:right">0.1645 ms</td>
<td style="text-align:right">0.1539 ms</td>
</tr>
<tr>
<td>ArrayEquals</td>
<td style="text-align:right">7.100 ms</td>
<td style="text-align:right">0.1289 ms</td>
<td style="text-align:right">0.1324 ms</td>
</tr>
</tbody>
</table>
<p>This is great! We are still making progress. Before F# had to figure out what method to call in order to evaluate equality. Here we can skip that and use a loop tuned for this exact problem.</p>
<h2 id="enter-the-simd">Enter the SIMD</h2>
<p>Now, I skipped something at the very beginning of this whole post. There was a version of my simulation code where the <code>Settings</code> type did not contain arrays. It was a more complex set of types. I&rsquo;ve been on a journey to learn how to write faster code because speed is a huge differentiator in my field. I work in a .NET shop, but we still want to have fast simulations. During my wanderings I have found <a href="https://en.wikipedia.org/wiki/Data-oriented_design">Data-Oriented Design</a> and <a href="https://en.wikipedia.org/wiki/Entity_component_system">Entity Component Systems</a>. These are broad topics, but they are really about arranging your data to achieve high performance.</p>
<p>I have been building code with a more Entity Component style. I&rsquo;m not building full Entity Component systems but I&rsquo;m tending toward Structs of Arrays (SoA) instead of Arrays of Structs (AoS) as a way to organize data (<a href="https://en.wikipedia.org/wiki/AoS_and_SoA">AoS vs SoA</a>). <code>Settings</code> is a type that has gone through that transformation. By arranging data in a way that is sympathetic to how computers work, we can achieve much better performance.</p>
<p>One of the tools that becomes available to you when you arrange your data in nice contiguous blocks of data is <a href="https://en.wikipedia.org/wiki/SIMD">SIMD instructions</a>. Practically all modern processors have special instructions which operate on multiple pieces of data simultaneously. This is exactly what we are doing with the equality checks in our <code>Equals</code> methods. For our first step into SIMD, let&rsquo;s use some <a href="https://en.wikipedia.org/wiki/SSE2">SSE2</a> instructions to test the equality of <code>array&lt;float&gt;</code>. SSE2 allows us to operate on 128 bits at a time. This means we can test the equality of 2 <code>float</code> at the same time.</p>
<blockquote>
<p><strong>Note</strong>: The Intrinsics libraries are designed as zero safeties type of library. It is incumbent on the developer to check whether the CPU actually has the required intrinsics available. Most modern x86 CPUs will have everything that I am showing. Best practice is to have code check as to whether the instructions are available and providing a fallback function if they are not. A fallback for us would simply be the code earlier in this post. Production code should contain checks and fallbacks. You have been warned.</p>
</blockquote>
<p>I am going to show you the function we will use for stepping through two arrays simultaneously and then break it down for you line by line. In this case I think it&rsquo;s easier for you to see the whole picture first and then have me explain what is happening to you.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">module</span> SseFloatArrayEquals <span style="color:#f92672">=</span>

    <span style="color:#75715e">// Open some new namespace we will need
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">open</span> FSharp.NativeInterop
    <span style="color:#66d9ef">open</span> System.Runtime.Intrinsics.X86
    <span style="color:#66d9ef">open</span> System.Runtime.Intrinsics

    <span style="color:#75715e">// Note, we are still using the same hashing functions. There just not shown for brevity
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// This is the new function we will use for comparing values
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> equals <span style="color:#f92672">(</span>a<span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;)</span> <span style="color:#f92672">(</span>b<span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;)</span> <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">if</span> a<span style="color:#f92672">.</span>Length <span style="color:#f92672">&lt;&gt;</span> b<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">then</span>
            invalidArg <span style="color:#f92672">(</span>nameof b<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;Cannot check equality on arrays of different lengths&#34;</span>
        
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
        <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> lastBlockIdx <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span>Length <span style="color:#f92672">-</span> <span style="color:#f92672">(</span>a<span style="color:#f92672">.</span>Length <span style="color:#f92672">%</span> Vector128<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;.</span>Count<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">use</span> aPointer <span style="color:#f92672">=</span> <span style="color:#66d9ef">fixed</span> a
        <span style="color:#66d9ef">use</span> bPointer <span style="color:#f92672">=</span> <span style="color:#66d9ef">fixed</span> b

        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> lastBlockIdx <span style="color:#f92672">&amp;&amp;</span> result <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> aVector <span style="color:#f92672">=</span> Sse2.LoadVector128 <span style="color:#f92672">(</span>NativePtr.add aPointer idx<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">let</span> bVector <span style="color:#f92672">=</span> Sse2.LoadVector128 <span style="color:#f92672">(</span>NativePtr.add bPointer idx<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">let</span> comparison <span style="color:#f92672">=</span> Sse2.CompareEqual <span style="color:#f92672">(</span>aVector<span style="color:#f92672">,</span> bVector<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">let</span> mask <span style="color:#f92672">=</span> Sse2.MoveMask comparison
            result <span style="color:#f92672">&lt;-</span> <span style="color:#f92672">(</span>mask <span style="color:#f92672">=</span> 3<span style="color:#f92672">)</span>

            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> Vector128<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;.</span>Count

        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> a<span style="color:#f92672">.</span>Length <span style="color:#f92672">&amp;&amp;</span> result <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">if</span> a<span style="color:#f92672">.[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;&gt;</span> b<span style="color:#f92672">.[</span>idx<span style="color:#f92672">]</span> <span style="color:#66d9ef">then</span>
                result <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">false</span>

            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1

        result
</code></pre></div><p>Okay, let&rsquo;s unpack what is happening in <code>equals</code>. In the first couple of lines, I&rsquo;m making sure that the two arrays are the same length.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">if</span> a<span style="color:#f92672">.</span>Length <span style="color:#f92672">&lt;&gt;</span> b<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">then</span>
    invalidArg <span style="color:#f92672">(</span>nameof b<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;Cannot check equality on arrays of different lengths&#34;</span>
</code></pre></div><p>Next I create some values I will be using to track my progress through the loop.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
</code></pre></div><p>I then need to calculate the last index at which I can use the SIMD instructions. Past this index I will need to fall back to scalar operations since I don&rsquo;t have a big enough chunk of data to work on.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> lastBlockIdx <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span>Length <span style="color:#f92672">-</span> <span style="color:#f92672">(</span>a<span style="color:#f92672">.</span>Length <span style="color:#f92672">%</span> Vector128<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;.</span>Count<span style="color:#f92672">)</span>
</code></pre></div><p>We now need to get a pointer to the arrays. The <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/fixed"><code>fixed</code></a> keyword is used to pin down the array and give us a pointer. We don&rsquo;t want the garbage collector moving data around while our function is running. This is what we use to tell the runtime to leave it alone until we are done with it. Instead of using <code>let</code> to bind the result, we use the <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/resource-management-the-use-keyword"><code>use</code></a> keyword. <code>use</code> tells the compiler that the resource should be collected once the value has gone out of scope. This is important since we don&rsquo;t want memory to stay pinned forever.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">use</span> aPointer <span style="color:#f92672">=</span> <span style="color:#66d9ef">fixed</span> a
<span style="color:#66d9ef">use</span> bPointer <span style="color:#f92672">=</span> <span style="color:#66d9ef">fixed</span> b
</code></pre></div><p>Now let&rsquo;s look at the loop where we are actually doing the work. The calls to <code>Sse2.LoadVector128</code> are loading the data into the registers to be worked on in parallel. <code>Sse2.CompareEqual</code> tells the CPU to compare the values in <code>aVector</code> and <code>bVector</code> for equality. If the values are equal, then it will set the result to 1 values. If they are not, they are set to 0.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> aVector <span style="color:#f92672">=</span> Sse2.LoadVector128 <span style="color:#f92672">(</span>NativePtr.add aPointer idx<span style="color:#f92672">)</span>
<span style="color:#66d9ef">let</span> bVector <span style="color:#f92672">=</span> Sse2.LoadVector128 <span style="color:#f92672">(</span>NativePtr.add bPointer idx<span style="color:#f92672">)</span>
<span style="color:#66d9ef">let</span> comparison <span style="color:#f92672">=</span> Sse2.CompareEqual <span style="color:#f92672">(</span>aVector<span style="color:#f92672">,</span> bVector<span style="color:#f92672">)</span>
</code></pre></div><p>Here&rsquo;s what this operation would look like if we were working in 8-bit. I&rsquo;m using 8-bit because I didn&rsquo;t want to have to draw out 32 boxes for 32-bit but the concepts translate to whatever bit-ness you are using. Here is what the data looks like if Vector A had the values 6 and 23 loaded in.</p>
<p><img src="vector_a_values.png" alt="Vector A Values"></p>
<p>And let&rsquo;s say we had the values 6 and 14 loaded into Vector B.</p>
<p><img src="vector_b_values.png" alt="Vector B Values"></p>
<p>When we perform the <code>Sse1.CompareEqual</code> method on these two vectors we will get 1&rsquo;s where the slots match, and 0&rsquo;s where they did not. Notice I said SLOT, not bit. You should think of it as the entire slot matching, not necessarily a number because this can be done with many different data types which have different widths.</p>
<p><img src="compare_equals_result.png" alt="Compare Equals Result"></p>
<p>Now we need to check the result of the comparison. We do that by calling <code>Sse2.MoveMask</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> mask <span style="color:#f92672">=</span> Sse2.MoveMask comparison
result <span style="color:#f92672">&lt;-</span> <span style="color:#f92672">(</span>mask <span style="color:#f92672">=</span> 3<span style="color:#f92672">)</span>
</code></pre></div><p><code>MoveMask</code> is calling a <code>MOVMSK</code> hardware intrinsic which is kind of a magical operation that confused me to no end. The explanation of it in the Intel documentation didn&rsquo;t help me much either. There are actually a lot of different <code>MOVMSK</code> intrinsics depending on the data you are working with. In our case it is working with a 64-bit float so it is calling <a href="https://www.laruence.com/x86/MOVMSKPD.html"><code>MOVMSKPD</code></a>. All <code>MOVMSK</code> operations take the highest order bit from each slot and put them in the lowest order bits in the output. This is effectively creating a <a href="https://en.wikipedia.org/wiki/Mask_(computing)">Bitmask</a>. A Bitmask can also be interpreted as an <code>int</code>.</p>
<p>Here is an example of what <code>MOVMSK</code> is doing using my 8-bit example.</p>
<p><img src="movemask_action.png" alt="Mask Result"></p>
<p>It moved the highest order bit from each slot into the lowest order bits on the output. This new mask gets interpreted as an <code>int</code> which has a value of <code>2</code>.</p>
<p>So, in this code, if both values match the output mask would have <code>11</code> in the lowest order bits of a 32-bit <code>int</code> which would be equivalent to <code>3</code>. That&rsquo;s why the test for whether all the values match is <code>mask = 3</code>.</p>
<p>Okay, we made it to the bottom of the loop. Now we just need to increment our index forward far enough to get a fresh set of values to load into our vectors. We want to increment by how many of our test elements fit into a <code>Vector128</code> which is why we add <code>Vector128&lt;float&gt;.Count</code> to the index.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp">idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> Vector128<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;.</span>Count
</code></pre></div><p>We will keep looping until we get through the elements, we can process using the vector operations. We then make it to the final loop which checks any remaining values that we need to process in a scalar way.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> a<span style="color:#f92672">.</span>Length <span style="color:#f92672">&amp;&amp;</span> result <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">if</span> a<span style="color:#f92672">.[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;&gt;</span> b<span style="color:#f92672">.[</span>idx<span style="color:#f92672">]</span> <span style="color:#66d9ef">then</span>
        result <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">false</span>

    idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1
</code></pre></div><p>Wow, that was a lot. Let&rsquo;s now create a <code>Settings</code> type that uses these SSE2 instructions and see if we get a speed up.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">module</span> SseFloatArrayEquals <span style="color:#f92672">=</span>

    <span style="color:#f92672">[&lt;</span>CustomEquality<span style="color:#f92672">;</span> NoComparison<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Settings</span> <span style="color:#f92672">=</span>
        <span style="color:#f92672">{</span>
            Levels <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
            MaxRates <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
            Buffers <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span>BufferState<span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">override</span> this.<span style="color:#a6e22e">Equals</span> b <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">match</span> b <span style="color:#66d9ef">with</span>
            <span style="color:#f92672">|</span> <span style="color:#f92672">:?</span> Settings <span style="color:#66d9ef">as</span> other <span style="color:#f92672">-&gt;</span>
                <span style="color:#f92672">(</span>equals this<span style="color:#f92672">.</span>Levels other<span style="color:#f92672">.</span>Levels<span style="color:#f92672">)</span>
                <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>equals this<span style="color:#f92672">.</span>MaxRates other<span style="color:#f92672">.</span>MaxRates<span style="color:#f92672">)</span>
                <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>equals this<span style="color:#f92672">.</span>Buffers other<span style="color:#f92672">.</span>Buffers<span style="color:#f92672">)</span>
            <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">false</span>
            
        <span style="color:#66d9ef">override</span> this.<span style="color:#a6e22e">GetHashCode</span> () <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">let</span> levelsHash <span style="color:#f92672">=</span> HashFloatArray this<span style="color:#f92672">.</span>Levels
            <span style="color:#66d9ef">let</span> maxRatesHash <span style="color:#f92672">=</span> HashFloatArray this<span style="color:#f92672">.</span>MaxRates
            <span style="color:#66d9ef">let</span> buffersHash <span style="color:#f92672">=</span> this<span style="color:#f92672">.</span>Buffers<span style="color:#f92672">.</span>GetHashCode()
            hash <span style="color:#f92672">(</span>levelsHash<span style="color:#f92672">,</span> maxRatesHash<span style="color:#f92672">,</span> buffersHash<span style="color:#f92672">)</span>
</code></pre></div><p>We then add our new benchmark&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Benchmarks</span> () <span style="color:#f92672">=</span>
    <span style="color:#75715e">// Previous benchmarks still here
</span><span style="color:#75715e"></span>    
    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">SseFloatArrayEquals</span> () <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> 0

        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> SseFloatArrayEquals.settingsKeys<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> testKey <span style="color:#f92672">=</span> SseFloatArrayEquals.settingsKeys<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span>
            result <span style="color:#f92672">&lt;-</span> SseFloatArrayEquals.settingsDictionary<span style="color:#f92672">[</span>testKey<span style="color:#f92672">]</span>

            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1

        result
</code></pre></div><p>&hellip;and compile and run. What do we get?</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
<th style="text-align:right">Median</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td style="text-align:right">39.472 ms</td>
<td style="text-align:right">0.4295 ms</td>
<td style="text-align:right">0.4018 ms</td>
<td style="text-align:right">39.438 ms</td>
</tr>
<tr>
<td>Simple</td>
<td style="text-align:right">39.010 ms</td>
<td style="text-align:right">0.5248 ms</td>
<td style="text-align:right">0.4909 ms</td>
<td style="text-align:right">39.157 ms</td>
</tr>
<tr>
<td>FloatHash</td>
<td style="text-align:right">10.989 ms</td>
<td style="text-align:right">0.1300 ms</td>
<td style="text-align:right">0.1216 ms</td>
<td style="text-align:right">11.033 ms</td>
</tr>
<tr>
<td>FloatHashShort</td>
<td style="text-align:right">9.554 ms</td>
<td style="text-align:right">0.1898 ms</td>
<td style="text-align:right">0.2400 ms</td>
<td style="text-align:right">9.410 ms</td>
</tr>
<tr>
<td>ArrayEquals</td>
<td style="text-align:right">7.286 ms</td>
<td style="text-align:right">0.0442 ms</td>
<td style="text-align:right">0.0392 ms</td>
<td style="text-align:right">7.274 ms</td>
</tr>
<tr>
<td>SseFloatArrayEquals</td>
<td style="text-align:right">6.453 ms</td>
<td style="text-align:right">0.0864 ms</td>
<td style="text-align:right">0.0808 ms</td>
<td style="text-align:right">6.440 ms</td>
</tr>
</tbody>
</table>
<p>Excellent. A little more progress but we&rsquo;d still like to see if we can get some more.</p>
<h2 id="bytes-all-the-way-down">Bytes all the way down</h2>
<p>There is a comparison that we haven&rsquo;t looked at yet. It&rsquo;s the equality of the <code>Buffers</code> field. You may remember that this field is an <code>array&lt;BufferState&gt;</code>. <code>BufferState</code> is a discriminated union and so far has been using the built in F# equality. Something important to note, the default DU is a reference type. This means that it is passed by reference and if you want to compare the equality of two different DUs, you&rsquo;ll need to follow there references to get the underlying data.</p>
<p>Fortunately, F# has added the ability to make struct DUs with the <code>[&lt;Struct&gt;]</code> keyword. This is great for high performance scenarios but there are downsides. I don&rsquo;t have the space to go into it here but will refer you to Bartosz Sypytkowski&rsquo;s excellent blog post <a href="https://bartoszsypytkowski.com/writing-high-performance-f-code/">here</a>. It&rsquo;s a great read and will provide you significant insight into how to get the most performance out of F#.</p>
<p>So why do I care about the fact that I can make the <code>BufferState</code> DU into a struct? Well, if I&rsquo;m storing all the data in an array and that data is a struct, then everything I need to compare will be contiguous. Now of course there are no hardware intrinsics in an x86 CPU for comparing F# types, but there are intrinsics for comparing raw bytes. If I can get a pointer to the <code>array&lt;BufferState&gt;</code> and simply compare the bytes for equality I can accelerate the equality check of the <code>Buffers</code> field as well.</p>
<p>Let&rsquo;s get to work. We&rsquo;ll need to define a new type <code>BufferStateStruct</code> which is exactly the same as a <code>BufferState</code> but with the <code>[&lt;Struct&gt;]</code> attribute. We&rsquo;ll put all this new code in a module called <code>SseByteArrayEquals</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">module</span> SseByteArrayEquals <span style="color:#f92672">=</span>

    <span style="color:#f92672">[&lt;</span>Struct<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BufferStateStruct</span> <span style="color:#f92672">=</span>
        <span style="color:#f92672">|</span> Full
        <span style="color:#f92672">|</span> Partial
        <span style="color:#f92672">|</span> Empty
</code></pre></div><p>Now we need to define a new <code>equals</code> function that can take two <code>array&lt;'T&gt;</code> and check their equality based on the bytes matching. Again, I&rsquo;m going to throw the whole function at you and then break it down. It&rsquo;s like what we went through in the previous section with some minor tweaks.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">module</span> SseByteArrayEquals <span style="color:#f92672">=</span>

    <span style="color:#66d9ef">let</span> private equals<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>T <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">&#39;</span>T <span style="color:#f92672">:</span> unmanaged<span style="color:#f92672">&gt;</span> <span style="color:#f92672">(</span>a<span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>T<span style="color:#f92672">&gt;)</span> <span style="color:#f92672">(</span>b<span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>T<span style="color:#f92672">&gt;)</span> <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">if</span> a<span style="color:#f92672">.</span>Length <span style="color:#f92672">&lt;&gt;</span> b<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">then</span>
            invalidArg <span style="color:#f92672">(</span>nameof b<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;Cannot perform equals on arrays of different lengths&#34;</span>
        
        <span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span>Length <span style="color:#f92672">*</span> sizeof<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">/</span> sizeof<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">&gt;</span>
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
        <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> lastBlockIdx <span style="color:#f92672">=</span> len <span style="color:#f92672">-</span> <span style="color:#f92672">(</span>len <span style="color:#f92672">%</span> Vector128<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">&gt;.</span>Count<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">use</span> pointerA <span style="color:#f92672">=</span> <span style="color:#66d9ef">fixed</span> a
        <span style="color:#66d9ef">use</span> pointerB <span style="color:#f92672">=</span> <span style="color:#66d9ef">fixed</span> b
        <span style="color:#66d9ef">let</span> bytePointerA <span style="color:#f92672">=</span> pointerA <span style="color:#f92672">|&gt;</span> NativePtr.toNativeInt <span style="color:#f92672">|&gt;</span> NativePtr.ofNativeInt<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">&gt;</span>
        <span style="color:#66d9ef">let</span> bytePointerB <span style="color:#f92672">=</span> pointerB <span style="color:#f92672">|&gt;</span> NativePtr.toNativeInt <span style="color:#f92672">|&gt;</span> NativePtr.ofNativeInt<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">&gt;</span>

        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span>lastBlockIdx <span style="color:#f92672">&amp;&amp;</span> result <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> aVector <span style="color:#f92672">=</span> Sse2.LoadVector128 <span style="color:#f92672">(</span>NativePtr.add bytePointerA idx<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">let</span> bVector <span style="color:#f92672">=</span> Sse2.LoadVector128 <span style="color:#f92672">(</span>NativePtr.add bytePointerB idx<span style="color:#f92672">)</span>

            <span style="color:#66d9ef">let</span> comparison <span style="color:#f92672">=</span> Sse2.CompareEqual <span style="color:#f92672">(</span>aVector<span style="color:#f92672">,</span> bVector<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">let</span> mask <span style="color:#f92672">=</span> Sse2.MoveMask <span style="color:#f92672">(</span>comparison<span style="color:#f92672">)</span>

            result <span style="color:#f92672">&lt;-</span> <span style="color:#f92672">(</span>mask <span style="color:#f92672">=</span> 65535<span style="color:#f92672">)</span>
            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> Vector128<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">&gt;.</span>Count

        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">&amp;&amp;</span> result <span style="color:#66d9ef">do</span>
            result <span style="color:#f92672">&lt;-</span> <span style="color:#f92672">((</span>NativePtr.get bytePointerA idx<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>NativePtr.get bytePointerB idx<span style="color:#f92672">))</span>
            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1

        result
</code></pre></div><p>Our function declarations have changed slightly. We now take an <code>array&lt;'T&gt;</code> but we added the restriction <code>unmanaged</code>. You can read more about type restrictions <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/constraints">here</a> but this restriction is necessary for us to be able to view the array as just a set of bytes.</p>
<p>At the beginning we have the same check to ensure that the arrays are the same length.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">if</span> a<span style="color:#f92672">.</span>Length <span style="color:#f92672">&lt;&gt;</span> b<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">then</span>
    invalidArg <span style="color:#f92672">(</span>nameof b<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;Cannot perform equals on arrays of different lengths&#34;</span>
</code></pre></div><p>We then need to know how long our arrays are in terms of the number of bytes since we will be operating on them as just bytes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span>Length <span style="color:#f92672">*</span> sizeof<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">/</span> sizeof<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">&gt;</span>
</code></pre></div><p>We then create <code>result</code> to track what we have found, create an <code>int</code> to track our progress and calculate the index of the last block we will be able to process using vector operations.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
<span style="color:#66d9ef">let</span> lastBlockIdx <span style="color:#f92672">=</span> len <span style="color:#f92672">-</span> <span style="color:#f92672">(</span>len <span style="color:#f92672">%</span> Vector128<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">&gt;.</span>Count<span style="color:#f92672">)</span>
</code></pre></div><p>We now get our pointers to pin the array down to prevent GC from moving things from underneath us.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">use</span> pointerA <span style="color:#f92672">=</span> <span style="color:#66d9ef">fixed</span> a
<span style="color:#66d9ef">use</span> pointerB <span style="color:#f92672">=</span> <span style="color:#66d9ef">fixed</span> b
</code></pre></div><p>What you can&rsquo;t see here is that <code>pointerA</code> and <code>pointerB</code> are both of type <code>nativeptr&lt;'T&gt;</code>. That&rsquo;s not what we want. We want a <code>nativeptr&lt;byte&gt;</code>. We use the functions in the <code>FSharp.NativeInterop</code> namespace to convert the pointer to a <code>nativeptr&lt;byte&gt;</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> bytePointerA <span style="color:#f92672">=</span> pointerA <span style="color:#f92672">|&gt;</span> NativePtr.toNativeInt <span style="color:#f92672">|&gt;</span> NativePtr.ofNativeInt<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">let</span> bytePointerB <span style="color:#f92672">=</span> pointerB <span style="color:#f92672">|&gt;</span> NativePtr.toNativeInt <span style="color:#f92672">|&gt;</span> NativePtr.ofNativeInt<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">&gt;</span>
</code></pre></div><p>The while loop for the vector operations is the same except for one difference. The mask value we check. Before we were comparing 2 floats at a time, so the possible mask values were <code>00</code>, <code>01</code>, <code>10</code>, and <code>11</code>. Now we are working in units of <code>byte</code> and we operate on 128 bits at a time. This means that when we call <code>MoveMask</code> we will generate a mask with potentially 16 1s in the least significant bits. If I type that out as bits it looks like this.</p>
<pre tabindex="0"><code>00000000 00000000 11111111 11111111
</code></pre><p>That mask is getting interpreted as a 32-bit number which gives a value of <code>65535</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> lastBlockIdx <span style="color:#f92672">&amp;&amp;</span> result <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">let</span> aVector <span style="color:#f92672">=</span> Sse2.LoadVector128 <span style="color:#f92672">(</span>NativePtr.add bytePointerA idx<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">let</span> bVector <span style="color:#f92672">=</span> Sse2.LoadVector128 <span style="color:#f92672">(</span>NativePtr.add bytePointerB idx<span style="color:#f92672">)</span>

    <span style="color:#66d9ef">let</span> comparison <span style="color:#f92672">=</span> Sse2.CompareEqual <span style="color:#f92672">(</span>aVector<span style="color:#f92672">,</span> bVector<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">let</span> mask <span style="color:#f92672">=</span> Sse2.MoveMask <span style="color:#f92672">(</span>comparison<span style="color:#f92672">)</span>

    result <span style="color:#f92672">&lt;-</span> <span style="color:#f92672">(</span>mask <span style="color:#f92672">=</span> 65535<span style="color:#f92672">)</span> <span style="color:#75715e">// This has changed since we are working in bytes.
</span><span style="color:#75715e"></span>    idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> Vector128<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">&gt;.</span>Count
</code></pre></div><p>The rest of the code in the function is the same as before so I won&rsquo;t go over it. Our <code>Settings</code> type can change though since our <code>array&lt;float&gt;</code> and <code>array&lt;BufferStateStruct&gt;</code> can both use this new <code>equals</code> function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp">    <span style="color:#f92672">[&lt;</span>CustomEquality<span style="color:#f92672">;</span> NoComparison<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Settings</span> <span style="color:#f92672">=</span>
        <span style="color:#f92672">{</span>
            Levels <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
            MaxRates <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>
            Buffers <span style="color:#f92672">:</span> array<span style="color:#f92672">&lt;</span>BufferStateStruct<span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">override</span> this.<span style="color:#a6e22e">Equals</span> b <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">match</span> b <span style="color:#66d9ef">with</span>
            <span style="color:#f92672">|</span> <span style="color:#f92672">:?</span> Settings <span style="color:#66d9ef">as</span> other <span style="color:#f92672">-&gt;</span>
                <span style="color:#75715e">// Notice that all of the arrays are using the same equals function
</span><span style="color:#75715e"></span>                <span style="color:#f92672">(</span>equals this<span style="color:#f92672">.</span>Levels other<span style="color:#f92672">.</span>Levels<span style="color:#f92672">)</span>
                <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>equals this<span style="color:#f92672">.</span>MaxRates other<span style="color:#f92672">.</span>MaxRates<span style="color:#f92672">)</span>
                <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>equals this<span style="color:#f92672">.</span>Buffers other<span style="color:#f92672">.</span>Buffers<span style="color:#f92672">)</span>
            <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">false</span>
            
        <span style="color:#66d9ef">override</span> this.<span style="color:#a6e22e">GetHashCode</span> () <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">let</span> levelsHash <span style="color:#f92672">=</span> HashFloatArray this<span style="color:#f92672">.</span>Levels
            <span style="color:#66d9ef">let</span> maxRatesHash <span style="color:#f92672">=</span> HashFloatArray this<span style="color:#f92672">.</span>MaxRates
            <span style="color:#66d9ef">let</span> buffersHash <span style="color:#f92672">=</span> this<span style="color:#f92672">.</span>Buffers<span style="color:#f92672">.</span>GetHashCode()
            hash <span style="color:#f92672">(</span>levelsHash<span style="color:#f92672">,</span> maxRatesHash<span style="color:#f92672">,</span> buffersHash<span style="color:#f92672">)</span>
</code></pre></div><p>We add another benchmark&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Benchmarks</span> () <span style="color:#f92672">=</span>

    <span style="color:#75715e">// ...previous benchmarks
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">SseByteArrayEquals</span> () <span style="color:#f92672">=</span>
        <span style="color:#66d9ef">let</span> mutable idx <span style="color:#f92672">=</span> 0
        <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> 0

        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> SseByteArrayEquals.settingsKeys<span style="color:#f92672">.</span>Length <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> testKey <span style="color:#f92672">=</span> SseByteArrayEquals.settingsKeys<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span>
            result <span style="color:#f92672">&lt;-</span> SseByteArrayEquals.settingsDictionary<span style="color:#f92672">[</span>testKey<span style="color:#f92672">]</span>

            idx <span style="color:#f92672">&lt;-</span> idx <span style="color:#f92672">+</span> 1

        result

</code></pre></div><p>&hellip;compile and run our tests to get the following.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td style="text-align:right">38.424 ms</td>
<td style="text-align:right">0.4668 ms</td>
<td style="text-align:right">0.4138 ms</td>
</tr>
<tr>
<td>Simple</td>
<td style="text-align:right">39.739 ms</td>
<td style="text-align:right">0.4141 ms</td>
<td style="text-align:right">0.3874 ms</td>
</tr>
<tr>
<td>FloatHash</td>
<td style="text-align:right">10.290 ms</td>
<td style="text-align:right">0.0969 ms</td>
<td style="text-align:right">0.0859 ms</td>
</tr>
<tr>
<td>FloatHashShort</td>
<td style="text-align:right">9.541 ms</td>
<td style="text-align:right">0.1061 ms</td>
<td style="text-align:right">0.0993 ms</td>
</tr>
<tr>
<td>ArrayEquals</td>
<td style="text-align:right">7.469 ms</td>
<td style="text-align:right">0.0763 ms</td>
<td style="text-align:right">0.0713 ms</td>
</tr>
<tr>
<td>SseFloatArrayEquals</td>
<td style="text-align:right">6.966 ms</td>
<td style="text-align:right">0.0580 ms</td>
<td style="text-align:right">0.0453 ms</td>
</tr>
<tr>
<td>SseByteArrayEquals</td>
<td style="text-align:right">1.653 ms</td>
<td style="text-align:right">0.0178 ms</td>
<td style="text-align:right">0.0149 ms</td>
</tr>
</tbody>
</table>
<p>This is great! We got another huge speed boost. Putting your data into vectors and using SIMD to rapidly process them can lead to some huge performance gains.</p>
<h2 id="wrap-up">Wrap Up</h2>
<p>I hope you enjoyed this journey. I had a lot of fun figuring out just how fast I could make this lookup since it is at the heart of some of the most performance sensitive code I wrote. I still have a lot to learn and if you have feedback, I would love to hear it! You can check out the code <a href="https://github.com/matthewcrews/RecordsAsKeysForDictionary">here</a>. You can run the benchmarks yourself and see what you find.</p>
<p>Please send me an email at <a href="mailto:matthewcrews@gmail.com">matthewcrews@gmail.com</a> if you have any questions and subscribe so you can stay on top new posts and products I am offering.</p>
<div class="col-8">
    <form action="https://matthewcrews.podia.com/email_lists/292490/subscriptions" accept-charset="UTF-8" method="post">
        <div class="call">
            <div class="call-box-top">
                <div class="call-email">
                    <input type="email" name="email" required="required" placeholder="Your email address..." style="width: 100%; height: 40px"/>
                </div>
              </div>
            <div class="call-box-bottom">
            <input class="button" type="submit" value="Sign me up!" />
            </div>
        </div>
    </form>
</div>
    
</div>
    </div>
  </div>
</div>

  </div>

  <div class="footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="footer-inner">
          <h3 class="footer-title">Matthew Crews</h3>
          <div id="footer-menu" class="footer-menu">
  
</div>

          
        </div>
      </div>
    </div>
  </div>
</div>
<script>
  MathJax = {
  tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
  };
</script>
<script id="MathJax-script" async
src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          
            
<div class="social">
    
        <a href="https://github.com/zerostaticthemes/hugo-serif-theme" target="blank"><img src="/images/social/github.svg" title="Github" alt="Github" /></a>
    
        <a href="https://twitter.com/zerostaticio" target="blank"><img src="/images/social/twitter.svg" title="Twitter" alt="Twitter" /></a>
    
</div>

          
          
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.98ee06cc35517b5800b382aecb0fc59893e95b9c11dd21842d0d57e4f68043e3.js"></script>
  

  






  





</body>

</html>
