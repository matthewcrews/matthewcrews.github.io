<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>SliceMap Rework - Part 2 | Matthew Crews</title>

<meta name="keywords" content="" />
<meta name="description" content="Welcome to part 2 of this series. In the previous post we setup our problem which is to speed up the SliceMap family of types for sparse data. We created benchmarks and measured the performance of the current implementation. I gave a brief overview of a new approach I had come up with and showed how it failed miserably.
We were in a depressing place at the end of the last post but hope burns eternal!">
<meta name="author" content="">
<link rel="canonical" href="https://matthewcrews.com/blog/2021/08/slicemap-rework-part-2/" />
<link href="/assets/css/stylesheet.min.d5d820de85dae34a78c22303e07aa685bb90ec25a056c702c0b1a964ca68861d.css" integrity="sha256-1dgg3oXa40p4wiMD4HqmhbuQ7CWgVscCwLGpZMpohh0=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://matthewcrews.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://matthewcrews.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://matthewcrews.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://matthewcrews.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://matthewcrews.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.78.2" />


<meta property="og:title" content="SliceMap Rework - Part 2" />
<meta property="og:description" content="Welcome to part 2 of this series. In the previous post we setup our problem which is to speed up the SliceMap family of types for sparse data. We created benchmarks and measured the performance of the current implementation. I gave a brief overview of a new approach I had come up with and showed how it failed miserably.
We were in a depressing place at the end of the last post but hope burns eternal!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://matthewcrews.com/blog/2021/08/slicemap-rework-part-2/" />
<meta property="article:published_time" content="2021-08-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-08-23T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SliceMap Rework - Part 2"/>
<meta name="twitter:description" content="Welcome to part 2 of this series. In the previous post we setup our problem which is to speed up the SliceMap family of types for sparse data. We created benchmarks and measured the performance of the current implementation. I gave a brief overview of a new approach I had come up with and showed how it failed miserably.
We were in a depressing place at the end of the last post but hope burns eternal!"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SliceMap Rework - Part 2",
  "name": "SliceMap Rework - Part 2",
  "description": "Welcome to part 2 of this series. In the previous post we setup our problem which is to speed up the SliceMap family of types for sparse data. We created benchmarks and measured ‚Ä¶",
  "keywords": [
    
  ],
  "articleBody": "Welcome to part 2 of this series. In the previous post we setup our problem which is to speed up the SliceMap family of types for sparse data. We created benchmarks and measured the performance of the current implementation. I gave a brief overview of a new approach I had come up with and showed how it failed miserably.\nWe were in a depressing place at the end of the last post but hope burns eternal! I have already been researching approaches for this problem on and off for a year, so I didn‚Äôt expect the problem to be slain in a day. Rather than giving up, I went searching for answers.\nEnter Data-Oriented Design Recently I have been researching Data-Oriented Design. My first introduction to it was a great talk by Mike Acton as CppCon. I regularly watch talks on other languages and paradigms to grow my understanding of the field and this talk in particular struck a chord. While some may find Mike‚Äôs delivery a little brusque, I found it refreshing. The talk is littered with great lines, but the following is one of my favorite.\n Reality is not a hack you‚Äôre forced to deal with to solve your abstract, theoretical problem. Reality is the actual problem.\nMike Acton\n Overall, Data-Oriented Design emphasizes data and its transformation as the key thing to design around. It generally eschews Object Orientation as a means of decomposing problems and instead looks at what data layouts and access patterns allow us to extract the maximum performance. This talk sent me deep down a rabbit hole. Eventually I found my way to Jonathan Blow who has given many great talks online. I decided to pick up the book ‚ÄúData-Oriented Design‚Äù by Richard Fabian.\nI‚Äôm still struggling with how I could use Data-Oriented Design to solve my slicing problem when I came to chapter 6 which discusses Searching. On page 114 of the paperback Richard describes how we can have data structures for looking up data that keep track of the query patterns being used. Once a threshold is met, the data could be re-ordered to better suit how the data is being accessed.\nThis was the moment of insight for me. ‚ÄúWait!‚Äù I said to myself. ‚ÄúIn real world use cases, you are often slicing across 1 dimension of the data many times in a row. Then you may start slicing across another dimension many times in a tight loop. Why not have the SliceMap re-order it‚Äôs data to be optimal for the types of lookups that are being performed!‚Äù\nIdea 3: Reorganizing Internals I went back to the drawing board and reworked how data was being stored in the SliceMap types. The internal fields of the 1 dimensional SliceMap remained simple. We give the SliceMap a comparer for comparing the keys when performing the Hadamard Product. keys is just a chunk of memory that is sorted. values is contiguous memory where the position is what determines the key it goes with.\ntype SliceMap'k, 'v when 'k : comparison (comparer: IComparer'k, keys: ReadOnlyMemory'k, values: ReadOnlyMemory'v) = let comparer = comparer let keys = keys let values = values SliceMap2D gets a little more interesting. We need to remember that a SliceMap2D can be thought of as a table in a database where the primary key is made up of two fields: Key1 and Key2. Here is what some example data could look like.\n   Key1 Key2 Value     1 ‚ÄúA‚Äù 2.0   1 ‚ÄúB‚Äù 8.0   1 ‚ÄúC‚Äù 3.0   2 ‚ÄúB‚Äù 1.7   2 ‚ÄúC‚Äù 1.7   3 ‚ÄúA‚Äù 9.4   3 ‚ÄúB‚Äù 4.6   ‚Ä¶ ‚Ä¶     Since we are trying to optimize the speed of slicing the data, we are willing to do some work up front to organize the data. When we initially create the SliceMap2D, we will sort the data by Key1 then Key2. This will allow us to use Run Length Encoding on the outer keys, Key1 in this case. We will store the length of the runs of the outer key in an IndexRange type.\n[Struct] type IndexRange = { Start : int Length : int } We will use two arrays for storing Key1 data. One array for the values of Key1, another for the IndexRange that corresponds to the key. We will call these fields OuterKeyValues and OuterKeyRanges respectively. Key2 and Values will be stored in a ReadOnlyMemory of their respective types. Key2 and Values have a 1 to 1 matching based on their location in their containers. We can now define SliceMap2DInternals for storing this information.\n[Struct] type SliceMap2DInternals'k1, 'k2, 'v when 'k1 : comparison and 'k2 : comparison = { OuterComparer : IComparer'k1 InnerComparer : IComparer'k2 OuterKeyValues : 'k1[] OuterKeyRanges : IndexRange[] InnerKeyValues : ReadOnlyMemory'k2 Values : ReadOnlyMemory'v } Now, you may notice that I was talking about Key1 and Key2 but then switched to talking about OuterKey and InnerKey. This is where things may get confusing but trust me, we‚Äôll get there! We need SliceMap2D to be able to restructure itself in order to provide fast slicing across Key1 or Key2. If Key1 data is stored in the OuterKey fields, then it is much faster to slice along Key1 because all we need to do it find the range of values it applies to and simply just slice the memory for InnerKeyValues and Values to create a SliceMap.\nIf Key2 is stored in the InnerKeyValues field, it is difficult to slice because a particular value of Key2 could occur in multiple places in InnerKeyValues. But what if we were able to flip which key was stored in the OuterKeyValues and OuterKeyRanges fields and which one was stored in InnerKeyValues? Well, then we could slice along the Key2 dimension quickly since all its values would be contiguous after flipping.\nThe ‚Äúproblem‚Äù is that F# is statically typed and doesn‚Äôt like you changing the type of fields. Fortunately, every problem in F# is solved with another type. Enter the SliceMap2DState.\ntype SliceMap2DState'k1, 'k2, 'v when 'k1 : comparison and 'k2 : comparison = | Key1Key2 of SliceMap2DInternals'k1, 'k2, 'v | Key2Key1 of SliceMap2DInternals'k2, 'k1, 'v What this Discriminated Union is doing is containing the information for how the keys are stored in the SliceMap2DInternals. It tells us if Key1 is in the outer fields or if Key2 is. Now we can define SliceMap2D.\ntype SliceMap2D'k1, 'k2, 'v when 'k1 : comparison and 'k2 : comparison (internalState: SliceMap2DState _, _) = let mutable internalState = internalState Notice, SliceMap2D is storing its state in a mutable field so it can change it when it wants. When you go to slice along a dimension, it will check how the data is laid out. If the data is not laid out for efficient slicing, it will swap the keys around. Here is what the slicing method looks like.\nmember _.Item // Ignoring `f` at this time  with get (x: 'k1, f: Filter) = // Get the internals  let internals = // Check which state the internals are in  match internalState with // This is the ideal state for serving up this slice so do nothing  | SliceMap2DState.Key1Key2 i - i // If the internals are in this state, we will swap the keys so  // that slicing can be fast  | SliceMap2DState.Key2Key1 i - let reOrdered = SliceMap2DInternals.swapKeys i internalState  SliceMap2DState.Key1Key2 reOrdered reOrdered let mutable intervalIdx = 0 let mutable keepSearching = true // Perform a scan to find the matching key. We'll come back to this üòâ  while keepSearching \u0026\u0026 intervalIdx  internals.OuterKeyValues.Length - 1 do if internals.OuterComparer.Compare (internals.OuterKeyValues[intervalIdx], x) = 0 then keepSearching  false else intervalIdx  intervalIdx + 1 if not keepSearching then // The key was found, and we can slice the contiguous data  let interval = internals.OuterKeyRanges[intervalIdx] // We have ensured that the pertinent data is contiguous so we can use  // slicing to get the necessary data  let newKeys = internals.InnerKeyValues.Slice (interval.Start, interval.Length) let newValues = internals.Values.Slice (interval.Start, interval.Length) // Return a SliceMap with the data slice  SliceMap (internals.InnerComparer, newKeys, newValues) else // The key was not found, return an empty SliceMap  SliceMap (internals.InnerComparer, ReadOnlyMemory Array.empty, ReadOnlyMemory Array.empty) The reason this is a valid optimization is that SliceMap was never intended as a general-purpose data structure. It was built to make composing Mathematical Planning problems clean and simple. When creating constraints, the dominant usage pattern is to perform the same slice many times for different values. Honestly, I put too much functionality into the original SliceMap. I lost focus on what the real problem was. You can see our solution up to this point at this repo and branch.\nDid We Get Faster? In the previous post we ran our benchmarks against the current implementation, and we got the following timings.\n   Method Mean Error StdDev     DenseData 7.993 s 0.0748 s 0.0700 s   MediumSparsity 2.154 s 0.0176 s 0.0156 s   HighSparsity 1.209 s 0.0134 s 0.0126 s    These are the timings we get for our new version of SliceMap2D with self-adjusting internals.\n   Method Mean Error StdDev     DenseData 379.05 ms 5.281 ms 4.940 ms   MediumSparsity 113.99 ms 0.647 ms 0.574 ms   HighSparsity 71.89 ms 0.636 ms 0.595 ms    It looks a little better when we plot the performance against each other.\nSo, it got a little faster üòä. I almost cried when I saw this. The fact that this problem has been tormenting me for over a year problem had something to do with it. We have even more gains on the horizon! There are several other things we can do to speed this up. Feel free to check out this repo and branch to see what all of the code looks like and run the benchmarks for yourself! I welcome feedback and ideas!\n",
  "wordCount" : "1613",
  "inLanguage": "en",
  "datePublished": "2021-08-23T00:00:00Z",
  "dateModified": "2021-08-23T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://matthewcrews.com/blog/2021/08/slicemap-rework-part-2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Matthew Crews",
    "logo": {
      "@type": "ImageObject",
      "url": "https://matthewcrews.com/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://matthewcrews.com" accesskey="h" title="Matthew Crews (Alt + H)">Matthew Crews</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://matthewcrews.com/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://matthewcrews.com/consulting" title="Consulting">
                    <span>Consulting</span>
                </a>
            </li>
            <li>
                <a href="https://matthewcrews.com/mathematical-planning" title="Mathamatical Planning">
                    <span>Mathamatical Planning</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      SliceMap Rework - Part 2
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">August 23, 2021

    </div>
  </header> 

  <div class="post-content">
<p>Welcome to part 2 of this series. In the <a href="/blog/2021/08/slicemap-rework-part-1/">previous post</a> we setup our problem which is to speed up the <code>SliceMap</code> family of types for sparse data. We created benchmarks and measured the performance of the current implementation. I gave a brief overview of a new approach I had come up with and showed how it failed miserably.</p>
<p>We were in a depressing place at the end of the last post but hope burns eternal! I have already been researching approaches for this problem on and off for a year, so I didn&rsquo;t expect the problem to be slain in a day. Rather than giving up, I went searching for answers.</p>
<h2 id="enter-data-oriented-design">Enter Data-Oriented Design<a hidden class="anchor" aria-hidden="true" href="#enter-data-oriented-design">#</a></h2>
<p>Recently I have been researching Data-Oriented Design. My first introduction to it was a great <a href="https://youtu.be/rX0ItVEVjHc">talk by Mike Acton</a> as <a href="https://cppcon.org/">CppCon</a>. I regularly watch talks on other languages and paradigms to grow my understanding of the field and this talk in particular struck a chord. While some may find Mike&rsquo;s delivery a little brusque, I found it refreshing. The talk is littered with great lines, but the following is one of my favorite.</p>
<blockquote>
<p>Reality is not a hack you&rsquo;re forced to deal with to solve your abstract, theoretical problem. Reality is the actual problem.</p>
<p>Mike Acton</p>
</blockquote>
<p>Overall, Data-Oriented Design emphasizes data and its transformation as the key thing to design around. It generally eschews Object Orientation as a means of decomposing problems and instead looks at what data layouts and access patterns allow us to extract the maximum performance. This talk sent me deep down a rabbit hole. Eventually I found my way to Jonathan Blow who has given many great talks online. I decided to pick up the book <a href="https://www.amazon.com/Data-oriented-design-engineering-resources-schedules/dp/1916478700/">&ldquo;Data-Oriented Design&rdquo;</a> by <a href="https://twitter.com/raspofabs">Richard Fabian</a>.</p>
<p>I&rsquo;m still struggling with how I could use Data-Oriented Design to solve my slicing problem when I came to chapter 6 which discusses Searching. On page 114 of the paperback Richard describes how we can have data structures for looking up data that keep track of the query patterns being used. Once a threshold is met, the data could be re-ordered to better suit how the data is being accessed.</p>
<p>This was the moment of insight for me. &ldquo;Wait!&rdquo; I said to myself. &ldquo;In real world use cases, you are often slicing across 1 dimension of the data many times in a row. Then you may start slicing across another dimension many times in a tight loop. Why not have the SliceMap re-order it&rsquo;s data to be optimal for the types of lookups that are being performed!&rdquo;</p>
<h2 id="idea-3-reorganizing-internals">Idea 3: Reorganizing Internals<a hidden class="anchor" aria-hidden="true" href="#idea-3-reorganizing-internals">#</a></h2>
<p>I went back to the drawing board and reworked how data was being stored in the <code>SliceMap</code> types. The internal fields of the 1 dimensional <code>SliceMap</code> remained simple. We give the <code>SliceMap</code> a comparer for comparing the keys when performing the Hadamard Product. <code>keys</code> is just a chunk of memory that is sorted. <code>values</code> is contiguous memory where the position is what determines the key it goes with.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SliceMap</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>k<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>v <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">&#39;</span>k <span style="color:#f92672">:</span> comparison<span style="color:#f92672">&gt;</span> 
    <span style="color:#f92672">(</span>comparer<span style="color:#f92672">:</span> IComparer<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>k<span style="color:#f92672">&gt;,</span> 
     keys<span style="color:#f92672">:</span> ReadOnlyMemory<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>k<span style="color:#f92672">&gt;,</span> 
     values<span style="color:#f92672">:</span> ReadOnlyMemory<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>v<span style="color:#f92672">&gt;)</span> <span style="color:#f92672">=</span>

    <span style="color:#66d9ef">let</span> comparer <span style="color:#f92672">=</span> comparer
    <span style="color:#66d9ef">let</span> keys <span style="color:#f92672">=</span> keys
    <span style="color:#66d9ef">let</span> values <span style="color:#f92672">=</span> values
</code></pre></div><p><code>SliceMap2D</code> gets a little more interesting. We need to remember that a <code>SliceMap2D</code> can be thought of as a table in a database where the primary key is made up of two fields: Key1 and Key2. Here is what some example data could look like.</p>
<table>
<thead>
<tr>
<th>Key1</th>
<th>Key2</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>&ldquo;A&rdquo;</td>
<td>2.0</td>
</tr>
<tr>
<td>1</td>
<td>&ldquo;B&rdquo;</td>
<td>8.0</td>
</tr>
<tr>
<td>1</td>
<td>&ldquo;C&rdquo;</td>
<td>3.0</td>
</tr>
<tr>
<td>2</td>
<td>&ldquo;B&rdquo;</td>
<td>1.7</td>
</tr>
<tr>
<td>2</td>
<td>&ldquo;C&rdquo;</td>
<td>1.7</td>
</tr>
<tr>
<td>3</td>
<td>&ldquo;A&rdquo;</td>
<td>9.4</td>
</tr>
<tr>
<td>3</td>
<td>&ldquo;B&rdquo;</td>
<td>4.6</td>
</tr>
<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td></td>
</tr>
</tbody>
</table>
<p>Since we are trying to optimize the speed of slicing the data, we are willing to do some work up front to organize the data. When we initially create the <code>SliceMap2D</code>, we will sort the data by Key1 then Key2. This will allow us to use <a href="https://en.wikipedia.org/wiki/Run-length_encoding">Run Length Encoding</a> on the outer keys, Key1 in this case. We will store the length of the runs of the outer key in an <code>IndexRange</code> type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#f92672">[&lt;</span>Struct<span style="color:#f92672">&gt;]</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IndexRange</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    Start <span style="color:#f92672">:</span> int
    Length <span style="color:#f92672">:</span> int
<span style="color:#f92672">}</span>
</code></pre></div><p>We will use two arrays for storing Key1 data. One array for the values of Key1, another for the <code>IndexRange</code> that corresponds to the key. We will call these fields <code>OuterKeyValues</code> and <code>OuterKeyRanges</code> respectively. Key2 and Values will be stored in a <code>ReadOnlyMemory</code> of their respective types. Key2 and Values have a 1 to 1 matching based on their location in their containers. We can now define <code>SliceMap2DInternals</code> for storing this information.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#f92672">[&lt;</span>Struct<span style="color:#f92672">&gt;]</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SliceMap2DInternals</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>k1<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>k2<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>v <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">&#39;</span>k1 <span style="color:#f92672">:</span> comparison <span style="color:#f92672">and</span> <span style="color:#66d9ef">&#39;</span>k2 <span style="color:#f92672">:</span> comparison<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    OuterComparer <span style="color:#f92672">:</span> IComparer<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>k1<span style="color:#f92672">&gt;</span>
    InnerComparer <span style="color:#f92672">:</span> IComparer<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>k2<span style="color:#f92672">&gt;</span>
    OuterKeyValues <span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>k1[]
    OuterKeyRanges <span style="color:#f92672">:</span> IndexRange[]
    InnerKeyValues <span style="color:#f92672">:</span> ReadOnlyMemory<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>k2<span style="color:#f92672">&gt;</span>
    Values <span style="color:#f92672">:</span> ReadOnlyMemory<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>v<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Now, you may notice that I was talking about Key1 and Key2 but then switched to talking about OuterKey and InnerKey. This is where things may get confusing but trust me, we&rsquo;ll get there! We need <code>SliceMap2D</code> to be able to restructure itself in order to provide fast slicing across Key1 or Key2. If Key1 data is stored in the OuterKey fields, then it is much faster to slice along Key1 because all we need to do it find the range of values it applies to and simply just slice the memory for <code>InnerKeyValues</code> and <code>Values</code> to create a <code>SliceMap</code>.</p>
<p>If Key2 is stored in the <code>InnerKeyValues</code> field, it is difficult to slice because a particular value of Key2 could occur in multiple places in <code>InnerKeyValues</code>. But what if we were able to flip which key was stored in the <code>OuterKeyValues</code> and <code>OuterKeyRanges</code> fields and which one was stored in <code>InnerKeyValues</code>? Well, then we could slice along the Key2 dimension quickly since all its values would be contiguous after flipping.</p>
<p>The &ldquo;problem&rdquo; is that F# is statically typed and doesn&rsquo;t like you changing the type of fields. Fortunately, every problem in F# is solved with another type. Enter the <code>SliceMap2DState</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SliceMap2DState</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>k1<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>k2<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>v <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">&#39;</span>k1 <span style="color:#f92672">:</span> comparison <span style="color:#f92672">and</span> <span style="color:#66d9ef">&#39;</span>k2 <span style="color:#f92672">:</span> comparison<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> Key1Key2 <span style="color:#66d9ef">of</span> SliceMap2DInternals<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>k1<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>k2<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>v<span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">|</span> Key2Key1 <span style="color:#66d9ef">of</span> SliceMap2DInternals<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>k2<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>k1<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>v<span style="color:#f92672">&gt;</span>
</code></pre></div><p>What this Discriminated Union is doing is containing the information for how the keys are stored in the <code>SliceMap2DInternals</code>. It tells us if Key1 is in the outer fields or if Key2 is. Now we can define <code>SliceMap2D</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SliceMap2D</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">&#39;</span>k1<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>k2<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>v <span style="color:#66d9ef">when</span> <span style="color:#66d9ef">&#39;</span>k1 <span style="color:#f92672">:</span> comparison <span style="color:#f92672">and</span> <span style="color:#66d9ef">&#39;</span>k2 <span style="color:#f92672">:</span> comparison<span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">(</span>internalState<span style="color:#f92672">:</span> SliceMap2DState<span style="color:#f92672">&lt;_,</span> <span style="color:#f92672">_,</span> <span style="color:#f92672">_&gt;)</span> <span style="color:#f92672">=</span>

    <span style="color:#66d9ef">let</span> mutable internalState <span style="color:#f92672">=</span> internalState
</code></pre></div><p>Notice, <code>SliceMap2D</code> is storing its state in a mutable field so it can change it when it wants. When you go to slice along a dimension, it will check how the data is laid out. If the data is not laid out for efficient slicing, it will swap the keys around. Here is what the slicing method looks like.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp">    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">Item</span>
        <span style="color:#75715e">// Ignoring `f` at this time
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">with</span> get <span style="color:#f92672">(</span>x<span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>k1<span style="color:#f92672">,</span> f<span style="color:#f92672">:</span> Filter<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>

            <span style="color:#75715e">// Get the internals
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">let</span> internals <span style="color:#f92672">=</span>
                <span style="color:#75715e">// Check which state the internals are in
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">match</span> internalState <span style="color:#66d9ef">with</span>
                <span style="color:#75715e">// This is the ideal state for serving up this slice so do nothing
</span><span style="color:#75715e"></span>                <span style="color:#f92672">|</span> SliceMap2DState.Key1Key2 i <span style="color:#f92672">-&gt;</span> i
                <span style="color:#75715e">// If the internals are in this state, we will swap the keys so
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// that slicing can be fast
</span><span style="color:#75715e"></span>                <span style="color:#f92672">|</span> SliceMap2DState.Key2Key1 i <span style="color:#f92672">-&gt;</span> 
                    <span style="color:#66d9ef">let</span> reOrdered <span style="color:#f92672">=</span> SliceMap2DInternals.swapKeys i
                    internalState <span style="color:#f92672">&lt;-</span> SliceMap2DState.Key1Key2 reOrdered
                    reOrdered

            <span style="color:#66d9ef">let</span> mutable intervalIdx <span style="color:#f92672">=</span> 0
            <span style="color:#66d9ef">let</span> mutable keepSearching <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>

            <span style="color:#75715e">// Perform a scan to find the matching key. We&#39;ll come back to this üòâ
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> keepSearching <span style="color:#f92672">&amp;&amp;</span> intervalIdx <span style="color:#f92672">&lt;</span> internals<span style="color:#f92672">.</span>OuterKeyValues<span style="color:#f92672">.</span>Length <span style="color:#f92672">-</span> 1 <span style="color:#66d9ef">do</span>
                <span style="color:#66d9ef">if</span> internals<span style="color:#f92672">.</span>OuterComparer<span style="color:#f92672">.</span>Compare <span style="color:#f92672">(</span>internals<span style="color:#f92672">.</span>OuterKeyValues<span style="color:#f92672">[</span>intervalIdx<span style="color:#f92672">],</span> x<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> 0 <span style="color:#66d9ef">then</span>
                    keepSearching <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">false</span>
                <span style="color:#66d9ef">else</span>
                    intervalIdx <span style="color:#f92672">&lt;-</span> intervalIdx <span style="color:#f92672">+</span> 1

            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> keepSearching <span style="color:#66d9ef">then</span>
                <span style="color:#75715e">// The key was found, and we can slice the contiguous data
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">let</span> interval <span style="color:#f92672">=</span> internals<span style="color:#f92672">.</span>OuterKeyRanges<span style="color:#f92672">[</span>intervalIdx<span style="color:#f92672">]</span>
                <span style="color:#75715e">// We have ensured that the pertinent data is contiguous so we can use
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// slicing to get the necessary data
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">let</span> newKeys <span style="color:#f92672">=</span> internals<span style="color:#f92672">.</span>InnerKeyValues<span style="color:#f92672">.</span>Slice <span style="color:#f92672">(</span>interval<span style="color:#f92672">.</span>Start<span style="color:#f92672">,</span> interval<span style="color:#f92672">.</span>Length<span style="color:#f92672">)</span>
                <span style="color:#66d9ef">let</span> newValues <span style="color:#f92672">=</span> internals<span style="color:#f92672">.</span>Values<span style="color:#f92672">.</span>Slice <span style="color:#f92672">(</span>interval<span style="color:#f92672">.</span>Start<span style="color:#f92672">,</span> interval<span style="color:#f92672">.</span>Length<span style="color:#f92672">)</span>
                <span style="color:#75715e">// Return a SliceMap with the data slice
</span><span style="color:#75715e"></span>                SliceMap <span style="color:#f92672">(</span>internals<span style="color:#f92672">.</span>InnerComparer<span style="color:#f92672">,</span> newKeys<span style="color:#f92672">,</span> newValues<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">else</span>
                <span style="color:#75715e">// The key was not found, return an empty SliceMap
</span><span style="color:#75715e"></span>                SliceMap <span style="color:#f92672">(</span>internals<span style="color:#f92672">.</span>InnerComparer<span style="color:#f92672">,</span> ReadOnlyMemory Array.empty<span style="color:#f92672">,</span> ReadOnlyMemory Array.empty<span style="color:#f92672">)</span>

</code></pre></div><p>The reason this is a valid optimization is that <code>SliceMap</code> was never intended as a general-purpose data structure. It was built to make composing Mathematical Planning problems clean and simple. When creating constraints, the dominant usage pattern is to perform the same slice many times for different values. Honestly, I put too much functionality into the original <code>SliceMap</code>. I lost focus on what the real problem was. You can see our solution up to this point at this <a href="https://github.com/matthewcrews/SliceMapPerformanceExploration/tree/step04-array-internals">repo and branch</a>.</p>
<h2 id="did-we-get-faster">Did We Get Faster?<a hidden class="anchor" aria-hidden="true" href="#did-we-get-faster">#</a></h2>
<p>In the previous post we ran our benchmarks against the current implementation, and we got the following timings.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>DenseData</td>
<td style="text-align:right">7.993 s</td>
<td style="text-align:right">0.0748 s</td>
<td style="text-align:right">0.0700 s</td>
</tr>
<tr>
<td>MediumSparsity</td>
<td style="text-align:right">2.154 s</td>
<td style="text-align:right">0.0176 s</td>
<td style="text-align:right">0.0156 s</td>
</tr>
<tr>
<td>HighSparsity</td>
<td style="text-align:right">1.209 s</td>
<td style="text-align:right">0.0134 s</td>
<td style="text-align:right">0.0126 s</td>
</tr>
</tbody>
</table>
<p>These are the timings we get for our new version of <code>SliceMap2D</code> with self-adjusting internals.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align:right">Mean</th>
<th style="text-align:right">Error</th>
<th style="text-align:right">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>DenseData</td>
<td style="text-align:right">379.05 ms</td>
<td style="text-align:right">5.281 ms</td>
<td style="text-align:right">4.940 ms</td>
</tr>
<tr>
<td>MediumSparsity</td>
<td style="text-align:right">113.99 ms</td>
<td style="text-align:right">0.647 ms</td>
<td style="text-align:right">0.574 ms</td>
</tr>
<tr>
<td>HighSparsity</td>
<td style="text-align:right">71.89 ms</td>
<td style="text-align:right">0.636 ms</td>
<td style="text-align:right">0.595 ms</td>
</tr>
</tbody>
</table>
<p>It looks a little better when we plot the performance against each other.</p>
<p><img src="SliceMapPerformanceDifference.PNG" alt="SliceMap Performance Difference"></p>
<p>So, it got a little faster üòä. I almost cried when I saw this. The fact that this problem has been tormenting me for over a year problem had something to do with it. We have even more gains on the horizon! There are several other things we can do to speed this up. Feel free to check out this <a href="https://github.com/matthewcrews/SliceMapPerformanceExploration/tree/step04-array-internals">repo and branch</a> to see what all of the code looks like and run the benchmarks for yourself! I welcome feedback and ideas!</p>

</div>
  <footer class="post-footer">



<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share SliceMap Rework - Part 2 on twitter"
        href="https://twitter.com/intent/tweet/?text=SliceMap%20Rework%20-%20Part%202&amp;url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-2%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SliceMap Rework - Part 2 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-2%2f&amp;title=SliceMap%20Rework%20-%20Part%202&amp;summary=SliceMap%20Rework%20-%20Part%202&amp;source=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-2%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SliceMap Rework - Part 2 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-2%2f&title=SliceMap%20Rework%20-%20Part%202">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SliceMap Rework - Part 2 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-2%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SliceMap Rework - Part 2 on whatsapp"
        href="https://api.whatsapp.com/send?text=SliceMap%20Rework%20-%20Part%202%20-%20https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-2%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SliceMap Rework - Part 2 on telegram"
        href="https://telegram.me/share/url?text=SliceMap%20Rework%20-%20Part%202&amp;url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-2%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://matthewcrews.com">Matthew Crews</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    MathJax = {
    tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
    };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</body>

</html>
