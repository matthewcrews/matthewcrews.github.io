<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>SliceMap Rework - Part 1 | Matthew Crews</title>

<meta name="keywords" content="" />
<meta name="description" content="I have been on a journey to overhaul the underpinnings of the Flips library and it has been a humbling experience. Part of what I believe provides a unique value add compared to other libraries for Mathematical Planning is the SliceMap types. They provide a convenient method for subsetting your data that is intuitive for someone who writes optimization models. The SliceMap types are heavily influenced by the TupleDict type in the Gurobi library for Python.">
<meta name="author" content="">
<link rel="canonical" href="https://matthewcrews.com/blog/2021/08/slicemap-rework-part-1/" />
<link href="/assets/css/stylesheet.min.d5d820de85dae34a78c22303e07aa685bb90ec25a056c702c0b1a964ca68861d.css" integrity="sha256-1dgg3oXa40p4wiMD4HqmhbuQ7CWgVscCwLGpZMpohh0=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://matthewcrews.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://matthewcrews.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://matthewcrews.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://matthewcrews.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://matthewcrews.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.78.2" />


<meta property="og:title" content="SliceMap Rework - Part 1" />
<meta property="og:description" content="I have been on a journey to overhaul the underpinnings of the Flips library and it has been a humbling experience. Part of what I believe provides a unique value add compared to other libraries for Mathematical Planning is the SliceMap types. They provide a convenient method for subsetting your data that is intuitive for someone who writes optimization models. The SliceMap types are heavily influenced by the TupleDict type in the Gurobi library for Python." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://matthewcrews.com/blog/2021/08/slicemap-rework-part-1/" />
<meta property="article:published_time" content="2021-08-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-08-16T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SliceMap Rework - Part 1"/>
<meta name="twitter:description" content="I have been on a journey to overhaul the underpinnings of the Flips library and it has been a humbling experience. Part of what I believe provides a unique value add compared to other libraries for Mathematical Planning is the SliceMap types. They provide a convenient method for subsetting your data that is intuitive for someone who writes optimization models. The SliceMap types are heavily influenced by the TupleDict type in the Gurobi library for Python."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SliceMap Rework - Part 1",
  "name": "SliceMap Rework - Part 1",
  "description": "I have been on a journey to overhaul the underpinnings of the Flips library and it has been a humbling experience. Part of what I believe provides a unique value add compared to ‚Ä¶",
  "keywords": [
    
  ],
  "articleBody": "I have been on a journey to overhaul the underpinnings of the Flips library and it has been a humbling experience. Part of what I believe provides a unique value add compared to other libraries for Mathematical Planning is the SliceMap types. They provide a convenient method for subsetting your data that is intuitive for someone who writes optimization models. The SliceMap types are heavily influenced by the TupleDict type in the Gurobi library for Python.\nThe major problem with SliceMap is that it does not scale well to sparse data sets. I knew this would be the case when I wrote it originally, but the performance was good enough at the time, so I decided to ship. Since then, this performance degradation has been a splinter in my mind that I simply could not shake. There had to be a way to do this well, I just didn‚Äôt know it yet.\nI have spent a year on and off searching for answers. I now have a shelf in my office that is full of books on algorithms, data structures, and multi-dimensional data structures. It‚Äôs all the best resources I could find that could possibly help me with this problem. While it was fun reading them, it ultimately didn‚Äôt help much. All these fancy data structures didn‚Äôt support what appeared to be a unique use case.\nThis series of posts is going to be me taking you through the journey to where I had the breakthrough and then kept on pushing. I have kept a repo set aside with branches which illustrate each of the milestones so you can see the impact. It includes code for easy benchmarking with benchmarkDotNet and code that you can profile yourself if you wish.\nMy goal is for you to see the mistakes and understand why some approaches are inefficient, even if the Big O notation says they should be faster. Also, I am not a ‚ÄúPro‚Äù performance person. I‚Äôm actively learning to diagnose and address performance issues so if you see that I missed something, please let me know! Let‚Äôs start our journey with understanding the domain we are working in and what the requirements of SliceMap are.\nThe Linear Programming Domain SliceMap is a set of types specifically for working in the Linear Programming and Mixed-Integer Programming domains. I often refer to these domains as ‚ÄúMathematical Planning‚Äù because they are primarily concerned with using mathematics to find the best possible plans. The word ‚ÄúProgram‚Äù used to mean ‚ÄúPlan‚Äù but now the word ‚ÄúProgram‚Äù has become overloaded since the advent of Computer Science, so I don‚Äôt like to use it anymore. The academic literature still calls it ‚ÄúLinear Programming‚Äù and ‚ÄúMixed-Integer Programming‚Äù though so if you go searching for more resources, you‚Äôll need to use the original terms.\nThe foundation of the LP and MIP domains is the humble Linear Expression. The term ‚ÄúLinear‚Äù in mathematics carries a special meaning that I won‚Äôt go into here. The key thing you need to know is that these expressions are straight. They are not curved in any way. Here are some examples of Linear Expressions:\n$$1.0 + x_{1} + 2 \\times x_{2}$$ $$3.5 \\times x_{1} + 5.7 \\times x_{2}$$ $$3.5 \\times x_{1} + 14.0$$\nThe most important thing to note is that you never see two $x$ multiplied together and there is no division. Here the $x$ values correspond to Decisions that we want to evaluate using Mathematical Planning. We can model this small domain using a simple set of types in F#.\ntype DecisionType = | Boolean | Integer of LowerBound:float * UpperBound:float | Continuous of LowerBound:float * UpperBound:float type DecisionName = DecisionName of string type Decision = { Name : DecisionName Type : DecisionType } type LinearExpr = | Float of float | Decision of Decision | Scale of scale: float * expr: LinearExpr | Add of lExpr: LinearExpr * rExpr: LinearExpr This doesn‚Äôt show you how these can interact though. If we add the operators for these types, we get the following.\ntype DecisionType = | Boolean | Integer of LowerBound:float * UpperBound:float | Continuous of LowerBound:float * UpperBound:float type DecisionName = DecisionName of string type Decision = { Name : DecisionName Type : DecisionType } with static member ( + ) (l: float, r: Decision) = LinearExpr.Add (LinearExpr.Float l, LinearExpr.Decision r) static member ( + ) (l: Decision, r: Decision) = LinearExpr.Add (LinearExpr.Decision l, LinearExpr.Decision r) static member ( * ) (l: float, r: Decision) = LinearExpr.Scale (l, LinearExpr.Decision r) [RequireQualifiedAccess] type LinearExpr = | Float of float | Decision of Decision | Scale of scale: float * expr: LinearExpr | Add of lExpr: LinearExpr * rExpr: LinearExpr static member ( + ) (l: float, r: LinearExpr) = LinearExpr.Add (LinearExpr.Float l, r) static member ( + ) (l: Decision, r: LinearExpr) = LinearExpr.Add (LinearExpr.Decision l, r) static member ( + ) (l: LinearExpr, r: LinearExpr) = LinearExpr.Add (l, r) static member ( * ) (l: float, r: LinearExpr) = LinearExpr.Scale (l, r) static member ( * ) (l: LinearExpr, r: float) = LinearExpr.Scale (r, l) static member Zero = LinearExpr.Float 0.0 The reason this is important is that we want to use SliceMap to be able to subset these types, multiply them together, and then sum the result. We aren‚Äôt just working with float values. It‚Äôs a more complex domain than that. If it was just float, I would have been trying to use SIMD or AVX instructions.\nSliceMap Requirements Okay, we‚Äôve talked a little about the primitives we are working with, let‚Äôs talk about what SliceMap needs to be able to do. Now, SliceMap is like tuples in F#. Tuples are not a single type; they are a family of types. A 2-element tuple is not the same as a 3-element tuple. In the same way SliceMap is a family of types and each has a dimensionality to it. The dimensionality corresponds to the keys being used to index the value. A SliceMap has a 1-dimensional key. A SliceMap2D has a 2-dimensional key and so on. Right now, I only plan on supporting up to a 5D key. I have not come across a real-world problem that needed a higher dimensional key.\nI think the best analogy for explaining what SliceMaps are meant to do is with database tables. Think of each SliceMap as a table where the 'key is unique and there is a corresponding value 'value. The table would look something like this.\n   Key Value     1 2.0   2 1.7   3 2.5   ‚Ä¶ ‚Ä¶    Now, a SliceMap2D would have two columns for the keys like so.\n   Key1 Key2 Value     1 ‚ÄúA‚Äù 2.0   1 ‚ÄúB‚Äù 8.0   1 ‚ÄúC‚Äù 3.0   2 ‚ÄúB‚Äù 1.7   2 ‚ÄúC‚Äù 1.7   3 ‚ÄúA‚Äù 9.4   3 ‚ÄúB‚Äù 4.6   ‚Ä¶ ‚Ä¶     Now, we would like to be able to subset these datasets quickly and easily. To simplify this for the developer, the SliceMap types provide several overloads for the Item method. Let‚Äôs look at an example. We will fill a SliceMap2D with some values and then select only the values where the first key is equal to 1 and we can slice it again but only take the values where the second key equals 2.\nlet key1 = [1..5] let key2 = [1..2] let sm2 = SliceMap2D [ for k1 in key1 do for k2 in key2 - k1, k2, k1 + k2 ] // slice will only contain the values where the first index = 1 let slice1 = sm2.[1, All] // slice2 will only contain values where the second index = 2 let slice2 = sm2.[All, 2] This ‚Äúslicing‚Äù provides a terse way to quickly filter down to the values that we care about. We then add the ability to take the Hadamard Product of two SliceMap. Think of this as an inner join on two tables. Where the keys match, the value in the two tables is multiplied. In Matlab and other languages it is the .* operator. It‚Äôs meant to signify element by element multiplication. In our case, whenever the keys match the values are multiplied. Here‚Äôs a quick example of what it looks like\nlet a = SliceMap [for i in 1..5 - i, i] let b = SliceMap [for i in 1..3 - i, i * i] let c = a .* b // The key/value pairs in `c` will be // [(1, 1); (2, 8); (3, 27)] The Hadamard Product of two SliceMap allow us to quickly multiply values together for the same key which is one of the cornerstones of Mathematical Planning. Finally, we then need to sum of these values to get the final result. We define a sum function which knows how to take any SliceMap and return the total of the values that it contains.\nlet a = SliceMap [for i in 1..5 - i, i] let b = SliceMap [for i in 1..3 - i, i * i] let c = a .* b let total = sum c // total is 36 If you want a deeper explanation of SliceMap and how they are meant to work, you can check out this page.\nBaseline Test  Note: If you want to see this code all at once, check out this repo and branch\n Now that we just had a whirlwind introduction to the Mathematical Planning domain and SliceMap, we can start talking about the implementation. We want to rewrite the SliceMap implementations to support fast slicing, Hadamard Product, and summing of values. Those are the critical operations. We also want it to be performance as the data becomes more sparse. Before we go about rewriting though, we should know what our current performance is.\nThe current implementation of SliceMap assumes that data is dense across all dimensions. This means that when it sums up values or performs a Hadamard Product, it will check every combination of keys to see if there is a value. Currently the actual values of the SliceMap are stored in a Dictionary and are accessed using a TryGetValue. For dense data, this is not a problem because every entry will have a value. As data gets sparse though, you end up doing a lot of unnecessary work.\nFor our baseline benchmarks we are going to test 3 different scenarios: Dense, Medium Sparsity, and High Sparsity. Dense for us will mean there is a value for every key. Medium sparsity will only have values for 10% of the possible keys. High Sparsity will have values only 1% of the time. Here is the code for setting up our data. We will have a set of Cities modeled as an int with a Unit of Measure and a set of Trucks also modeled as an int with Unit of Measure.\n[Measure] type City [Measure] type Truck let rng = Random 123 let numberOfCities = 1_000 let numberOfTrucks = 1_000 let cities = [| for c in 1 .. numberOfCities - LanguagePrimitives.Int32WithMeasureCity c |] let trucks = [| for t in 1 .. numberOfTrucks - LanguagePrimitives.Int32WithMeasureTruck t|] We then create some random Cost and Capacity data that we will use in our SliceMaps.\nlet costs = SliceMap [| for t in trucks - t, 100.0 + 10.0 * rng.NextDouble() |] let capacity = SliceMap [| for t in trucks - t, 1_000.0 + 10.0 * rng.NextDouble () |] We now create a Decision for the pairs of City and Truck that we are modeling.\nlet cityTruckPairs = [| for c in cities do for t in trucks - c, t |] // For the Dense case let decisions = SliceMap2D [| for (c, t) in cityTruckPairs - let decisionName = DecisionName ($\"{c.ToString()}_{t.ToString()}\") c, t, { Name = decisionName; Type = DecisionType.Boolean } |] For the Medium and Highly sparse cases we generate our SliceMap2D of Decision differently. We randomly omit pairs of City and Truck to make the data sparse.\n// Medium Density case let densityPercent = 0.10 let cityTruckPairs = [| for c in cities do for t in trucks - if rng.NextDouble()  densityPercent then Some (c, t) else None |] | Array.choose id // Medium Density decisions let decisions = SliceMap2D [| for (c, t) in cityTruckPairs - let decisionName = DecisionName ($\"{c.ToString()}_{t.ToString()}\") c, t, { Name = decisionName; Type = DecisionType.Boolean } |] And for Sparse we only accept 1% of the pairs.\nlet densityPercent = 0.01 let cityTruckPairs = [| for c in cities do for t in trucks - if rng.NextDouble()  densityPercent then Some (c, t) else None |] | Array.choose id let decisions = SliceMap2D [| for (c, t) in cityTruckPairs - let decisionName = DecisionName ($\"{c.ToString()}_{t.ToString()}\") c, t, { Name = decisionName; Type = DecisionType.Boolean } |] Now that we have setup our data, we can run some benchmarks! We will use benchmarkDotNet which makes this type of work incredibly easy. For each case we create a loop function which iterates through each of the Cities in our data and computes a linear expression using the SliceMaps we populated, the Hadamard Product, and summing them. We loop through all the Cities 10 times so that our test is sufficiently long. Anything under 100 ms causes a warning from benchmarkDotNet that the test may be too short and the results not valid. We are assigning to a mutable value and returning it to ensure that the compiler doesn‚Äôt do something clever and just skip unused code.\n// There's a loop like this for each case let loop () = let mutable result = LanguagePrimitives.GenericZero for _ = 1 to 10 do for c in cities do let total = sum (capacity .* decisions.[c, All] .* costs) result  total result We then create a class to hold our tests for benchmarkDotNet.\n[MemoryDiagnoser] type Benchmarks () = [Benchmark] member _.DenseData () = Dense.loop () [Benchmark] member _.MediumSparsity () = MediumSparsity.loop () [Benchmark] member _.HighSparsity () = HighSparsity.loop () We can now add a call to the main function to run the benchmarks.\n[EntryPoint] let main argv = let summary = BenchmarkRunner.RunBenchmarks() 0 // return an integer exit code We can build using the Release settings and run the command line. At the end we get the following table from benchmarkDotNet.\n| Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Allocated | |--------------- |--------:|---------:|---------:|-------------:|------------:|----------:| | DenseData | 7.993 s | 0.0748 s | 0.0700 s | 1380000.0000 | 308000.0000 | 11 GB | | MediumSparsity | 2.154 s | 0.0176 s | 0.0156 s | 360000.0000 | 28000.0000 | 3 GB | | HighSparsity | 1.209 s | 0.0134 s | 0.0126 s | 183000.0000 | 10000.0000 | 1 GB | We now have a baseline of performance to judge improvements on. If you want to run this yourself, check out this repo and branch. Let‚Äôs see what we can do to improve this!\nFirst failure: Clever IEnumerable The first thing I tried when I came back to this problem was to try to be cleverer about which keys I iterated through. The idea was to encode the outer keys with a Run-Length Encoding and the inner keys would have an index for the next time that value showed up. This meant if I slice the outer dimension, I will only look at the small section for that run. If I slice the inner dimensions, I can find the first instance of a value and then just skip from row to row.\nI know that‚Äôs not a detailed explanation, but I don‚Äôt think it‚Äôs worth going into the details. You can see the code here if you want. The reason it‚Äôs not worth the explanation can be found in the performance results.\n| Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Allocated | |--------------- |---------:|---------:|---------:|--------------:|------------:|----------:| | DenseData | 86.070 s | 0.4374 s | 0.4091 s | 24980000.0000 | 287000.0000 | 195 GB | | MediumSparsity | 10.592 s | 0.0938 s | 0.0832 s | 3094000.0000 | 33000.0000 | 24 GB | | HighSparsity | 3.343 s | 0.0289 s | 0.0270 s | 842000.0000 | 6000.0000 | 7 GB | This was deeply disappointing. Even though I was able to skip so many values, the overhead of the IEnumerable and the fact that I was skipping all over these arrays caused havoc. This is a case of trying to be too clever and it can bite you. I may have theoretically been doing less work, but the algorithm was so much less friendly for the CPU and I suffered the consequences.\nNow, I didn‚Äôt want to give up right away with this approach. I took a long time coming up with it. I thought that maybe I had done something silly and had made some error. I decided to profile to find what I was doing wrong. I like to use dotTrace and dotMemory for this kind of work. I‚Äôve recently also started using Superluminal which shows a lot of promise.\nSecond Failure: Struct Tuples Isn‚Äôt Enough When I ran the code through dotMemory I saw that I was generating a huge number of tuples. These were coming from the calls to Seq.unfold which was using a normal F# tuple which is a ref type.\nI knew I could cut down on the GC if I converted these to struct tuples. I went ahead and made the change which you can check out here. Sadly, this helped some, but not enough.\n| Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Allocated | |--------------- |---------:|---------:|---------:|------------:|------------:|----------:| | DenseData | 51.158 s | 0.1429 s | 0.1337 s | 949000.0000 | 182000.0000 | 7 GB | | MediumSparsity | 7.619 s | 0.0367 s | 0.0344 s | 549000.0000 | 17000.0000 | 4 GB | | HighSparsity | 2.934 s | 0.0223 s | 0.0209 s | 467000.0000 | 4000.0000 | 4 GB | There were some additional things that I could have done to try to eek out some more performance but I knew none of them had the potential to give me a 10x or more improvement which was what I was really looking for. I sat with this for a day trying to see if I had missed something obvious but nothing came to me. It looks like the clever enumeration approach is a dead end.\nWhere from here? Fortunately, this story does have a good ending but it will have to wait for my next post. I had to go back to the drawing board and rethink my approach. Fortunately, I had picked up Data-Oreinted Design and had been reading through it for inspiration. In it I found an idea that proved to be the key to unlocking this problem. Sorry to leave you hanging but this dad needs some sleep üò¥.\n",
  "wordCount" : "3134",
  "inLanguage": "en",
  "datePublished": "2021-08-16T00:00:00Z",
  "dateModified": "2021-08-16T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://matthewcrews.com/blog/2021/08/slicemap-rework-part-1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Matthew Crews",
    "logo": {
      "@type": "ImageObject",
      "url": "https://matthewcrews.com/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://matthewcrews.com" accesskey="h" title="Matthew Crews (Alt + H)">Matthew Crews</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://matthewcrews.com/about" title="About">
                    <span>About</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      SliceMap Rework - Part 1
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">August 16, 2021

    </div>
  </header> 

  <div class="post-content">
<p>I have been on a journey to overhaul the underpinnings of the <a href="https://flipslibrary.com/#/">Flips</a> library and it has been a humbling experience. Part of what I believe provides a unique value add compared to other libraries for Mathematical Planning is the <code>SliceMap</code> types. They provide a convenient method for subsetting your data that is intuitive for someone who writes optimization models. The <code>SliceMap</code> types are heavily influenced by the <code>TupleDict</code> type in the <a href="https://www.gurobi.com/documentation/9.1/refman/py_tupledict.html">Gurobi library</a> for Python.</p>
<p>The major problem with <code>SliceMap</code> is that it does not scale well to sparse data sets. I knew this would be the case when I wrote it originally, but the performance was good enough at the time, so I decided to ship. Since then, this performance degradation has been a splinter in my mind that I simply could not shake. There had to be a way to do this well, I just didn&rsquo;t know it yet.</p>
<p>I have spent a year on and off searching for answers. I now have a shelf in my office that is full of books on algorithms, data structures, and multi-dimensional data structures. It&rsquo;s all the best resources I could find that could possibly help me with this problem. While it was fun reading them, it ultimately didn&rsquo;t help much. All these fancy data structures didn&rsquo;t support what appeared to be a unique use case.</p>
<p>This series of posts is going to be me taking you through the journey to where I had the breakthrough and then kept on pushing. I have kept a repo set aside with branches which illustrate each of the milestones so you can see the impact. It includes code for easy benchmarking with <a href="https://github.com/dotnet/BenchmarkDotNet">benchmarkDotNet</a> and code that you can profile yourself if you wish.</p>
<p>My goal is for you to see the mistakes and understand why some approaches are inefficient, even if the <a href="https://en.wikipedia.org/wiki/Big_O_notation">Big O notation</a> says they should be faster. Also, I am not a &ldquo;Pro&rdquo; performance person. I&rsquo;m actively learning to diagnose and address performance issues so if you see that I missed something, please let me know! Let&rsquo;s start our journey with understanding the domain we are working in and what the requirements of <code>SliceMap</code> are.</p>
<h2 id="the-linear-programming-domain">The Linear Programming Domain<a hidden class="anchor" aria-hidden="true" href="#the-linear-programming-domain">#</a></h2>
<p><code>SliceMap</code> is a set of types specifically for working in the <a href="https://en.wikipedia.org/wiki/Linear_programming">Linear Programming</a> and <a href="https://en.wikipedia.org/wiki/Linear_programming">Mixed-Integer Programming</a> domains. I often refer to these domains as &ldquo;Mathematical Planning&rdquo; because they are primarily concerned with using mathematics to find the best possible plans. The word &ldquo;Program&rdquo; used to mean &ldquo;Plan&rdquo; but now the word &ldquo;Program&rdquo; has become overloaded since the advent of Computer Science, so I don&rsquo;t like to use it anymore. The academic literature still calls it &ldquo;Linear Programming&rdquo; and &ldquo;Mixed-Integer Programming&rdquo; though so if you go searching for more resources, you&rsquo;ll need to use the original terms.</p>
<p>The foundation of the LP and MIP domains is the humble Linear Expression. The term &ldquo;Linear&rdquo; in mathematics carries a special meaning that I won&rsquo;t go into here. The key thing you need to know is that these expressions are straight. They are not curved in any way. Here are some examples of Linear Expressions:</p>
<p>$$1.0 + x_{1} + 2 \times x_{2}$$
$$3.5 \times x_{1} + 5.7 \times x_{2}$$
$$3.5 \times x_{1} + 14.0$$</p>
<p>The most important thing to note is that you never see two $x$ multiplied together and there is no division. Here the $x$ values correspond to Decisions that we want to evaluate using Mathematical Planning. We can model this small domain using a simple set of types in F#.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DecisionType</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> Boolean
    <span style="color:#f92672">|</span> Integer <span style="color:#66d9ef">of</span> LowerBound<span style="color:#f92672">:</span><span style="color:#66d9ef">float</span> <span style="color:#f92672">*</span> UpperBound<span style="color:#f92672">:</span><span style="color:#66d9ef">float</span>
    <span style="color:#f92672">|</span> Continuous <span style="color:#66d9ef">of</span> LowerBound<span style="color:#f92672">:</span><span style="color:#66d9ef">float</span> <span style="color:#f92672">*</span> UpperBound<span style="color:#f92672">:</span><span style="color:#66d9ef">float</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DecisionName</span> <span style="color:#f92672">=</span> DecisionName <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Decision</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    Name <span style="color:#f92672">:</span> DecisionName
    Type <span style="color:#f92672">:</span> DecisionType
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">LinearExpr</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> Float <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">float</span>
    <span style="color:#f92672">|</span> Decision <span style="color:#66d9ef">of</span> Decision
    <span style="color:#f92672">|</span> Scale <span style="color:#66d9ef">of</span> scale<span style="color:#f92672">:</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">*</span> expr<span style="color:#f92672">:</span> LinearExpr
    <span style="color:#f92672">|</span> Add <span style="color:#66d9ef">of</span> lExpr<span style="color:#f92672">:</span> LinearExpr <span style="color:#f92672">*</span> rExpr<span style="color:#f92672">:</span> LinearExpr
</code></pre></div><p>This doesn&rsquo;t show you how these can interact though. If we add the operators for these types, we get the following.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DecisionType</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> Boolean
    <span style="color:#f92672">|</span> Integer <span style="color:#66d9ef">of</span> LowerBound<span style="color:#f92672">:</span><span style="color:#66d9ef">float</span> <span style="color:#f92672">*</span> UpperBound<span style="color:#f92672">:</span><span style="color:#66d9ef">float</span>
    <span style="color:#f92672">|</span> Continuous <span style="color:#66d9ef">of</span> LowerBound<span style="color:#f92672">:</span><span style="color:#66d9ef">float</span> <span style="color:#f92672">*</span> UpperBound<span style="color:#f92672">:</span><span style="color:#66d9ef">float</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DecisionName</span> <span style="color:#f92672">=</span> DecisionName <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Decision</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    Name <span style="color:#f92672">:</span> DecisionName
    Type <span style="color:#f92672">:</span> DecisionType
<span style="color:#f92672">}</span> <span style="color:#66d9ef">with</span>

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">member</span> <span style="color:#f92672">(</span> <span style="color:#f92672">+</span> <span style="color:#f92672">)</span> <span style="color:#f92672">(</span>l<span style="color:#f92672">:</span> <span style="color:#66d9ef">float</span><span style="color:#f92672">,</span> r<span style="color:#f92672">:</span> Decision<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
        LinearExpr.Add <span style="color:#f92672">(</span>LinearExpr.Float l<span style="color:#f92672">,</span> LinearExpr.Decision r<span style="color:#f92672">)</span>

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">member</span> <span style="color:#f92672">(</span> <span style="color:#f92672">+</span> <span style="color:#f92672">)</span> <span style="color:#f92672">(</span>l<span style="color:#f92672">:</span> Decision<span style="color:#f92672">,</span> r<span style="color:#f92672">:</span> Decision<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
        LinearExpr.Add <span style="color:#f92672">(</span>LinearExpr.Decision l<span style="color:#f92672">,</span> LinearExpr.Decision r<span style="color:#f92672">)</span>

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">member</span> <span style="color:#f92672">(</span> <span style="color:#f92672">*</span> <span style="color:#f92672">)</span> <span style="color:#f92672">(</span>l<span style="color:#f92672">:</span> <span style="color:#66d9ef">float</span><span style="color:#f92672">,</span> r<span style="color:#f92672">:</span> Decision<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
        LinearExpr.Scale <span style="color:#f92672">(</span>l<span style="color:#f92672">,</span> LinearExpr.Decision r<span style="color:#f92672">)</span>


<span style="color:#f92672">[&lt;</span>RequireQualifiedAccess<span style="color:#f92672">&gt;]</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">LinearExpr</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> Float <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">float</span>
    <span style="color:#f92672">|</span> Decision <span style="color:#66d9ef">of</span> Decision
    <span style="color:#f92672">|</span> Scale <span style="color:#66d9ef">of</span> scale<span style="color:#f92672">:</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">*</span> expr<span style="color:#f92672">:</span> LinearExpr
    <span style="color:#f92672">|</span> Add <span style="color:#66d9ef">of</span> lExpr<span style="color:#f92672">:</span> LinearExpr <span style="color:#f92672">*</span> rExpr<span style="color:#f92672">:</span> LinearExpr

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">member</span> <span style="color:#f92672">(</span> <span style="color:#f92672">+</span> <span style="color:#f92672">)</span> <span style="color:#f92672">(</span>l<span style="color:#f92672">:</span> <span style="color:#66d9ef">float</span><span style="color:#f92672">,</span> r<span style="color:#f92672">:</span> LinearExpr<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
        LinearExpr.Add <span style="color:#f92672">(</span>LinearExpr.Float l<span style="color:#f92672">,</span> r<span style="color:#f92672">)</span>

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">member</span> <span style="color:#f92672">(</span> <span style="color:#f92672">+</span> <span style="color:#f92672">)</span> <span style="color:#f92672">(</span>l<span style="color:#f92672">:</span> Decision<span style="color:#f92672">,</span> r<span style="color:#f92672">:</span> LinearExpr<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
        LinearExpr.Add <span style="color:#f92672">(</span>LinearExpr.Decision l<span style="color:#f92672">,</span> r<span style="color:#f92672">)</span>

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">member</span> <span style="color:#f92672">(</span> <span style="color:#f92672">+</span> <span style="color:#f92672">)</span> <span style="color:#f92672">(</span>l<span style="color:#f92672">:</span> LinearExpr<span style="color:#f92672">,</span> r<span style="color:#f92672">:</span> LinearExpr<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
        LinearExpr.Add <span style="color:#f92672">(</span>l<span style="color:#f92672">,</span> r<span style="color:#f92672">)</span>

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">member</span> <span style="color:#f92672">(</span> <span style="color:#f92672">*</span> <span style="color:#f92672">)</span> <span style="color:#f92672">(</span>l<span style="color:#f92672">:</span> <span style="color:#66d9ef">float</span><span style="color:#f92672">,</span> r<span style="color:#f92672">:</span> LinearExpr<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
        LinearExpr.Scale <span style="color:#f92672">(</span>l<span style="color:#f92672">,</span> r<span style="color:#f92672">)</span>

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">member</span> <span style="color:#f92672">(</span> <span style="color:#f92672">*</span> <span style="color:#f92672">)</span> <span style="color:#f92672">(</span>l<span style="color:#f92672">:</span> LinearExpr<span style="color:#f92672">,</span> r<span style="color:#f92672">:</span> <span style="color:#66d9ef">float</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
        LinearExpr.Scale <span style="color:#f92672">(</span>r<span style="color:#f92672">,</span> l<span style="color:#f92672">)</span>

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">member</span> Zero <span style="color:#f92672">=</span> LinearExpr.Float 0<span style="color:#f92672">.</span>0
</code></pre></div><p>The reason this is important is that we want to use <code>SliceMap</code> to be able to subset these types, multiply them together, and then sum the result. We aren&rsquo;t just working with <code>float</code> values. It&rsquo;s a more complex domain than that. If it was just float, I would have been trying to use <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> or <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> instructions.</p>
<h2 id="slicemap-requirements">SliceMap Requirements<a hidden class="anchor" aria-hidden="true" href="#slicemap-requirements">#</a></h2>
<p>Okay, we&rsquo;ve talked a little about the primitives we are working with, let&rsquo;s talk about what <code>SliceMap</code> needs to be able to do. Now, <code>SliceMap</code> is like tuples in F#. Tuples are not a single type; they are a family of types. A 2-element tuple is not the same as a 3-element tuple. In the same way <code>SliceMap</code> is a family of types and each has a dimensionality to it. The dimensionality corresponds to the keys being used to index the value. A <code>SliceMap</code> has a 1-dimensional key. A <code>SliceMap2D</code> has a 2-dimensional key and so on. Right now, I only plan on supporting up to a 5D key. I have not come across a real-world problem that needed a higher dimensional key.</p>
<p>I think the best analogy for explaining what <code>SliceMap</code>s are meant to do is with database tables. Think of each <code>SliceMap</code> as a table where the <code>'key</code> is unique and there is a corresponding value <code>'value</code>. The table would look something like this.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2.0</td>
</tr>
<tr>
<td>2</td>
<td>1.7</td>
</tr>
<tr>
<td>3</td>
<td>2.5</td>
</tr>
<tr>
<td>&hellip;</td>
<td>&hellip;</td>
</tr>
</tbody>
</table>
<p>Now, a <code>SliceMap2D</code> would have two columns for the keys like so.</p>
<table>
<thead>
<tr>
<th>Key1</th>
<th>Key2</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>&ldquo;A&rdquo;</td>
<td>2.0</td>
</tr>
<tr>
<td>1</td>
<td>&ldquo;B&rdquo;</td>
<td>8.0</td>
</tr>
<tr>
<td>1</td>
<td>&ldquo;C&rdquo;</td>
<td>3.0</td>
</tr>
<tr>
<td>2</td>
<td>&ldquo;B&rdquo;</td>
<td>1.7</td>
</tr>
<tr>
<td>2</td>
<td>&ldquo;C&rdquo;</td>
<td>1.7</td>
</tr>
<tr>
<td>3</td>
<td>&ldquo;A&rdquo;</td>
<td>9.4</td>
</tr>
<tr>
<td>3</td>
<td>&ldquo;B&rdquo;</td>
<td>4.6</td>
</tr>
<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td></td>
</tr>
</tbody>
</table>
<p>Now, we would like to be able to subset these datasets quickly and easily. To simplify this for the developer, the <code>SliceMap</code> types provide several overloads for the <code>Item</code> method. Let&rsquo;s look at an example. We will fill a <code>SliceMap2D</code> with some values and then select only the values where the first key is equal to <code>1</code> and we can slice it again but only take the values where the second key equals <code>2</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> key1 <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>1<span style="color:#f92672">..</span>5<span style="color:#f92672">]</span>
<span style="color:#66d9ef">let</span> key2 <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>1<span style="color:#f92672">..</span>2<span style="color:#f92672">]</span>
<span style="color:#66d9ef">let</span> sm2 <span style="color:#f92672">=</span> 
    SliceMap2D <span style="color:#f92672">[</span>
        <span style="color:#66d9ef">for</span> k1 <span style="color:#66d9ef">in</span> key1 <span style="color:#66d9ef">do</span> 
        <span style="color:#66d9ef">for</span> k2 <span style="color:#66d9ef">in</span> key2 <span style="color:#f92672">-&gt;</span> 
        k1<span style="color:#f92672">,</span> k2<span style="color:#f92672">,</span> k1 <span style="color:#f92672">+</span> k2
    <span style="color:#f92672">]</span>

<span style="color:#75715e">// slice will only contain the values where the first index = 1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> slice1 <span style="color:#f92672">=</span> sm2<span style="color:#f92672">.[</span>1<span style="color:#f92672">,</span> All<span style="color:#f92672">]</span>

<span style="color:#75715e">// slice2 will only contain values where the second index = 2
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> slice2 <span style="color:#f92672">=</span> sm2<span style="color:#f92672">.[</span>All<span style="color:#f92672">,</span> 2<span style="color:#f92672">]</span>
</code></pre></div><p>This &ldquo;slicing&rdquo; provides a terse way to quickly filter down to the values that we care about. We then add the ability to take the <a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">Hadamard Product</a> of two <code>SliceMap</code>. Think of this as an inner join on two tables. Where the keys match, the value in the two tables is multiplied. In Matlab and other languages it is the <code>.*</code> operator. It&rsquo;s meant to signify element by element multiplication. In our case, whenever the keys match the values are multiplied. Here&rsquo;s a quick example of what it looks like</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> SliceMap <span style="color:#f92672">[</span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> 1<span style="color:#f92672">..</span>5 <span style="color:#f92672">-&gt;</span> i<span style="color:#f92672">,</span> i<span style="color:#f92672">]</span>
<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> SliceMap <span style="color:#f92672">[</span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> 1<span style="color:#f92672">..</span>3 <span style="color:#f92672">-&gt;</span> i<span style="color:#f92672">,</span> i <span style="color:#f92672">*</span> i<span style="color:#f92672">]</span>
<span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> a <span style="color:#f92672">.*</span> b
<span style="color:#75715e">// The key/value pairs in `c` will be
</span><span style="color:#75715e">// [(1, 1); (2, 8); (3, 27)]
</span></code></pre></div><p>The Hadamard Product of two <code>SliceMap</code> allow us to quickly multiply values together for the same key which is one of the cornerstones of Mathematical Planning. Finally, we then need to sum of these values to get the final result. We define a <code>sum</code> function which knows how to take any <code>SliceMap</code> and return the total of the values that it contains.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> SliceMap <span style="color:#f92672">[</span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> 1<span style="color:#f92672">..</span>5 <span style="color:#f92672">-&gt;</span> i<span style="color:#f92672">,</span> i<span style="color:#f92672">]</span>
<span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> SliceMap <span style="color:#f92672">[</span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> 1<span style="color:#f92672">..</span>3 <span style="color:#f92672">-&gt;</span> i<span style="color:#f92672">,</span> i <span style="color:#f92672">*</span> i<span style="color:#f92672">]</span>
<span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> a <span style="color:#f92672">.*</span> b
<span style="color:#66d9ef">let</span> total <span style="color:#f92672">=</span> sum c
<span style="color:#75715e">// total is 36
</span></code></pre></div><p>If you want a deeper explanation of <code>SliceMap</code> and how they are meant to work, you can check out <a href="https://flipslibrary.com/#/slicemaps/">this page</a>.</p>
<h2 id="baseline-test">Baseline Test<a hidden class="anchor" aria-hidden="true" href="#baseline-test">#</a></h2>
<blockquote>
<p><strong>Note:</strong> If you want to see this code all at once, check out this <a href="https://github.com/matthewcrews/SliceMapPerformanceExploration/tree/step01-uom">repo and branch</a></p>
</blockquote>
<p>Now that we just had a whirlwind introduction to the Mathematical Planning domain and <code>SliceMap</code>, we can start talking about the implementation. We want to rewrite the <code>SliceMap</code> implementations to support fast slicing, Hadamard Product, and summing of values. Those are the critical operations. We also want it to be performance as the data becomes more sparse. Before we go about rewriting though, we should know what our current performance is.</p>
<p>The current implementation of <code>SliceMap</code> assumes that data is dense across all dimensions. This means that when it sums up values or performs a Hadamard Product, it will check every combination of keys to see if there is a value. Currently the actual values of the <code>SliceMap</code> are stored in a <code>Dictionary</code> and are accessed using a <code>TryGetValue</code>. For dense data, this is not a problem because every entry will have a value. As data gets sparse though, you end up doing a lot of unnecessary work.</p>
<p>For our baseline benchmarks we are going to test 3 different scenarios: Dense, Medium Sparsity, and High Sparsity. Dense for us will mean there is a value for every key. Medium sparsity will only have values for 10% of the possible keys. High Sparsity will have values only 1% of the time. Here is the code for setting up our data. We will have a set of Cities modeled as an <code>int</code> with a Unit of Measure and a set of Trucks also modeled as an <code>int</code> with Unit of Measure.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#f92672">[&lt;</span>Measure<span style="color:#f92672">&gt;]</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">City</span>
<span style="color:#f92672">[&lt;</span>Measure<span style="color:#f92672">&gt;]</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Truck</span>

<span style="color:#66d9ef">let</span> rng <span style="color:#f92672">=</span> Random 123
<span style="color:#66d9ef">let</span> numberOfCities <span style="color:#f92672">=</span> 1_000
<span style="color:#66d9ef">let</span> numberOfTrucks <span style="color:#f92672">=</span> 1_000
<span style="color:#66d9ef">let</span> cities <span style="color:#f92672">=</span> <span style="color:#f92672">[|</span> <span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> 1 <span style="color:#f92672">..</span> numberOfCities <span style="color:#f92672">-&gt;</span> LanguagePrimitives.Int32WithMeasure<span style="color:#f92672">&lt;</span>City<span style="color:#f92672">&gt;</span> c <span style="color:#f92672">|]</span>
<span style="color:#66d9ef">let</span> trucks <span style="color:#f92672">=</span> <span style="color:#f92672">[|</span> <span style="color:#66d9ef">for</span> t <span style="color:#66d9ef">in</span> 1 <span style="color:#f92672">..</span> numberOfTrucks <span style="color:#f92672">-&gt;</span> LanguagePrimitives.Int32WithMeasure<span style="color:#f92672">&lt;</span>Truck<span style="color:#f92672">&gt;</span> t<span style="color:#f92672">|]</span>
</code></pre></div><p>We then create some random Cost and Capacity data that we will use in our <code>SliceMap</code>s.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> costs <span style="color:#f92672">=</span>
    SliceMap <span style="color:#f92672">[|</span>
        <span style="color:#66d9ef">for</span> t <span style="color:#66d9ef">in</span> trucks <span style="color:#f92672">-&gt;</span>
            t<span style="color:#f92672">,</span> 100<span style="color:#f92672">.</span>0 <span style="color:#f92672">+</span> 10<span style="color:#f92672">.</span>0 <span style="color:#f92672">*</span> rng<span style="color:#f92672">.</span>NextDouble()
    <span style="color:#f92672">|]</span>

<span style="color:#66d9ef">let</span> capacity <span style="color:#f92672">=</span>
    SliceMap <span style="color:#f92672">[|</span>
        <span style="color:#66d9ef">for</span> t <span style="color:#66d9ef">in</span> trucks <span style="color:#f92672">-&gt;</span>
            t<span style="color:#f92672">,</span> 1_000<span style="color:#f92672">.</span>0 <span style="color:#f92672">+</span> 10<span style="color:#f92672">.</span>0 <span style="color:#f92672">*</span> rng<span style="color:#f92672">.</span>NextDouble () 
    <span style="color:#f92672">|]</span>
</code></pre></div><p>We now create a <code>Decision</code> for the pairs of City and Truck that we are modeling.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> cityTruckPairs <span style="color:#f92672">=</span>
    <span style="color:#f92672">[|</span> 
        <span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> cities <span style="color:#66d9ef">do</span>
        <span style="color:#66d9ef">for</span> t <span style="color:#66d9ef">in</span> trucks <span style="color:#f92672">-&gt;</span>
            c<span style="color:#f92672">,</span> t
    <span style="color:#f92672">|]</span>

<span style="color:#75715e">// For the Dense case
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> decisions <span style="color:#f92672">=</span>
    SliceMap2D <span style="color:#f92672">[|</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> t<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span> cityTruckPairs <span style="color:#f92672">-&gt;</span>
            <span style="color:#66d9ef">let</span> decisionName <span style="color:#f92672">=</span> DecisionName <span style="color:#f92672">($</span><span style="color:#e6db74">&#34;{c.ToString()}_{t.ToString()}&#34;</span><span style="color:#f92672">)</span>
            c<span style="color:#f92672">,</span> t<span style="color:#f92672">,</span> <span style="color:#f92672">{</span> Name <span style="color:#f92672">=</span> decisionName<span style="color:#f92672">;</span> Type <span style="color:#f92672">=</span> DecisionType.Boolean <span style="color:#f92672">}</span>
    <span style="color:#f92672">|]</span>
</code></pre></div><p>For the Medium and Highly sparse cases we generate our <code>SliceMap2D</code> of <code>Decision</code> differently. We randomly omit pairs of City and Truck to make the data sparse.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#75715e">// Medium Density case
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> densityPercent <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span>10

<span style="color:#66d9ef">let</span> cityTruckPairs <span style="color:#f92672">=</span>
    <span style="color:#f92672">[|</span> 
        <span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> cities <span style="color:#66d9ef">do</span>
        <span style="color:#66d9ef">for</span> t <span style="color:#66d9ef">in</span> trucks <span style="color:#f92672">-&gt;</span>
            <span style="color:#66d9ef">if</span> rng<span style="color:#f92672">.</span>NextDouble() <span style="color:#f92672">&lt;</span> densityPercent <span style="color:#66d9ef">then</span>
                Some <span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> t<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">else</span>
                None
    <span style="color:#f92672">|]</span> <span style="color:#f92672">|&gt;</span> Array.choose id

<span style="color:#75715e">// Medium Density decisions
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> decisions <span style="color:#f92672">=</span>
    SliceMap2D <span style="color:#f92672">[|</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> t<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span> cityTruckPairs <span style="color:#f92672">-&gt;</span>
            <span style="color:#66d9ef">let</span> decisionName <span style="color:#f92672">=</span> DecisionName <span style="color:#f92672">($</span><span style="color:#e6db74">&#34;{c.ToString()}_{t.ToString()}&#34;</span><span style="color:#f92672">)</span>
            c<span style="color:#f92672">,</span> t<span style="color:#f92672">,</span> <span style="color:#f92672">{</span> Name <span style="color:#f92672">=</span> decisionName<span style="color:#f92672">;</span> Type <span style="color:#f92672">=</span> DecisionType.Boolean <span style="color:#f92672">}</span>
    <span style="color:#f92672">|]</span>
</code></pre></div><p>And for Sparse we only accept 1% of the pairs.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> densityPercent <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span>01

<span style="color:#66d9ef">let</span> cityTruckPairs <span style="color:#f92672">=</span>
    <span style="color:#f92672">[|</span> 
        <span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> cities <span style="color:#66d9ef">do</span>
        <span style="color:#66d9ef">for</span> t <span style="color:#66d9ef">in</span> trucks <span style="color:#f92672">-&gt;</span>
            <span style="color:#66d9ef">if</span> rng<span style="color:#f92672">.</span>NextDouble() <span style="color:#f92672">&lt;</span> densityPercent <span style="color:#66d9ef">then</span>
                Some <span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> t<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">else</span>
                None
    <span style="color:#f92672">|]</span> <span style="color:#f92672">|&gt;</span> Array.choose id

<span style="color:#66d9ef">let</span> decisions <span style="color:#f92672">=</span>
    SliceMap2D <span style="color:#f92672">[|</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> t<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span> cityTruckPairs <span style="color:#f92672">-&gt;</span>
            <span style="color:#66d9ef">let</span> decisionName <span style="color:#f92672">=</span> DecisionName <span style="color:#f92672">($</span><span style="color:#e6db74">&#34;{c.ToString()}_{t.ToString()}&#34;</span><span style="color:#f92672">)</span>
            c<span style="color:#f92672">,</span> t<span style="color:#f92672">,</span> <span style="color:#f92672">{</span> Name <span style="color:#f92672">=</span> decisionName<span style="color:#f92672">;</span> Type <span style="color:#f92672">=</span> DecisionType.Boolean <span style="color:#f92672">}</span>
    <span style="color:#f92672">|]</span>
</code></pre></div><p>Now that we have setup our data, we can run some benchmarks! We will use benchmarkDotNet which makes this type of work incredibly easy. For each case we create a <code>loop</code> function which iterates through each of the Cities in our data and computes a linear expression using the <code>SliceMap</code>s we populated, the Hadamard Product, and summing them. We loop through all the Cities 10 times so that our test is sufficiently long. Anything under 100 ms causes a warning from benchmarkDotNet that the test may be too short and the results not valid. We are assigning to a <code>mutable</code> value and returning it to ensure that the compiler doesn&rsquo;t do something clever and just skip unused code.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#75715e">// There&#39;s a loop like this for each case
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> loop () <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> mutable result <span style="color:#f92672">=</span> LanguagePrimitives.GenericZero

    <span style="color:#66d9ef">for</span> <span style="color:#f92672">_</span> <span style="color:#f92672">=</span> 1 <span style="color:#66d9ef">to</span> 10 <span style="color:#66d9ef">do</span>
        <span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> cities <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">let</span> total <span style="color:#f92672">=</span> sum <span style="color:#f92672">(</span>capacity <span style="color:#f92672">.*</span> decisions<span style="color:#f92672">.[</span>c<span style="color:#f92672">,</span> All<span style="color:#f92672">]</span> <span style="color:#f92672">.*</span> costs<span style="color:#f92672">)</span>
            result <span style="color:#f92672">&lt;-</span> total

    result
</code></pre></div><p>We then create a class to hold our tests for benchmarkDotNet.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#f92672">[&lt;</span>MemoryDiagnoser<span style="color:#f92672">&gt;]</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Benchmarks</span> () <span style="color:#f92672">=</span>

    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">DenseData</span> () <span style="color:#f92672">=</span>
        Dense.loop ()

    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">MediumSparsity</span> () <span style="color:#f92672">=</span>
        MediumSparsity.loop ()

    <span style="color:#f92672">[&lt;</span>Benchmark<span style="color:#f92672">&gt;]</span>
    <span style="color:#66d9ef">member</span> _.<span style="color:#a6e22e">HighSparsity</span> () <span style="color:#f92672">=</span>
        HighSparsity.loop ()
</code></pre></div><p>We can now add a call to the <code>main</code> function to run the benchmarks.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#f92672">[&lt;</span>EntryPoint<span style="color:#f92672">&gt;]</span>
<span style="color:#66d9ef">let</span> main argv <span style="color:#f92672">=</span>

    <span style="color:#66d9ef">let</span> summary <span style="color:#f92672">=</span> BenchmarkRunner.Run<span style="color:#f92672">&lt;</span>Benchmarks<span style="color:#f92672">&gt;</span>()
    0 <span style="color:#75715e">// return an integer exit code
</span></code></pre></div><p>We can build using the <code>Release</code> settings and run the command line. At the end we get the following table from benchmarkDotNet.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-md" data-lang="md">|         Method |    Mean |    Error |   StdDev |        Gen 0 |       Gen 1 | Allocated |
|--------------- |--------:|---------:|---------:|-------------:|------------:|----------:|
|      DenseData | 7.993 s | 0.0748 s | 0.0700 s | 1380000.0000 | 308000.0000 |     11 GB |
| MediumSparsity | 2.154 s | 0.0176 s | 0.0156 s |  360000.0000 |  28000.0000 |      3 GB |
|   HighSparsity | 1.209 s | 0.0134 s | 0.0126 s |  183000.0000 |  10000.0000 |      1 GB |
</code></pre></div><p>We now have a baseline of performance to judge improvements on. If you want to run this yourself, check out this <a href="https://github.com/matthewcrews/SliceMapPerformanceExploration/tree/step01-uom">repo and branch</a>. Let&rsquo;s see what we can do to improve this!</p>
<h2 id="first-failure-clever-ienumerable">First failure: Clever IEnumerable<a hidden class="anchor" aria-hidden="true" href="#first-failure-clever-ienumerable">#</a></h2>
<p>The first thing I tried when I came back to this problem was to try to be cleverer about which keys I iterated through. The idea was to encode the outer keys with a <a href="https://en.wikipedia.org/wiki/Run-length_encoding">Run-Length Encoding</a> and the inner keys would have an index for the next time that value showed up. This meant if I slice the outer dimension, I will only look at the small section for that run. If I slice the inner dimensions, I can find the first instance of a value and then just skip from row to row.</p>
<p>I know that&rsquo;s not a detailed explanation, but I don&rsquo;t think it&rsquo;s worth going into the details. You can see the code <a href="https://github.com/matthewcrews/SliceMapPerformanceExploration/tree/step02-new-algorithm">here</a> if you want. The reason it&rsquo;s not worth the explanation can be found in the performance results.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-md" data-lang="md">|         Method |     Mean |    Error |   StdDev |         Gen 0 |       Gen 1 | Allocated |
|--------------- |---------:|---------:|---------:|--------------:|------------:|----------:|
|      DenseData | 86.070 s | 0.4374 s | 0.4091 s | 24980000.0000 | 287000.0000 |    195 GB |
| MediumSparsity | 10.592 s | 0.0938 s | 0.0832 s |  3094000.0000 |  33000.0000 |     24 GB |
|   HighSparsity |  3.343 s | 0.0289 s | 0.0270 s |   842000.0000 |   6000.0000 |      7 GB |
</code></pre></div><p>This was deeply disappointing. Even though I was able to skip so many values, the overhead of the IEnumerable and the fact that I was skipping all over these arrays caused havoc. This is a case of trying to be too clever and it can bite you. I may have theoretically been doing less work, but the algorithm was so much less friendly for the CPU and I suffered the consequences.</p>
<p>Now, I didn&rsquo;t want to give up right away with this approach. I took a long time coming up with it. I thought that maybe I had done something silly and had made some error. I decided to profile to find what I was doing wrong. I like to use <a href="https://www.jetbrains.com/profiler/">dotTrace</a> and <a href="https://www.jetbrains.com/dotmemory/">dotMemory</a> for this kind of work. I&rsquo;ve recently also started using <a href="https://superluminal.eu/">Superluminal</a> which shows a lot of promise.</p>
<h2 id="second-failure-struct-tuples-isnt-enough">Second Failure: Struct Tuples Isn&rsquo;t Enough<a hidden class="anchor" aria-hidden="true" href="#second-failure-struct-tuples-isnt-enough">#</a></h2>
<p>When I ran the code through dotMemory I saw that I was generating a huge number of tuples. These were coming from the calls to <code>Seq.unfold</code> which was using a normal F# tuple which is a ref type.</p>
<p><img src="GeneratingTuples.PNG" alt="Generating Tuples"></p>
<p>I knew I could cut down on the GC if I converted these to <code>struct</code> tuples. I went ahead and made the change which you can check out <a href="https://github.com/matthewcrews/SliceMapPerformanceExploration/tree/step03-struct-tuples">here</a>. Sadly, this helped some, but not enough.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-md" data-lang="md">|         Method |     Mean |    Error |   StdDev |       Gen 0 |       Gen 1 | Allocated |
|--------------- |---------:|---------:|---------:|------------:|------------:|----------:|
|      DenseData | 51.158 s | 0.1429 s | 0.1337 s | 949000.0000 | 182000.0000 |      7 GB |
| MediumSparsity |  7.619 s | 0.0367 s | 0.0344 s | 549000.0000 |  17000.0000 |      4 GB |
|   HighSparsity |  2.934 s | 0.0223 s | 0.0209 s | 467000.0000 |   4000.0000 |      4 GB |
</code></pre></div><p>There were some additional things that I could have done to try to eek out some more performance but I knew none of them had the potential to give me a 10x or more improvement which was what I was really looking for. I sat with this for a day trying to see if I had missed something obvious but nothing came to me. It looks like the clever enumeration approach is a dead end.</p>
<h2 id="where-from-here">Where from here?<a hidden class="anchor" aria-hidden="true" href="#where-from-here">#</a></h2>
<p>Fortunately, this story does have a good ending but it will have to wait for my next post. I had to go back to the drawing board and rethink my approach. Fortunately, I had picked up <a href="https://www.amazon.com/gp/product/1916478700/">Data-Oreinted Design</a> and had been reading through it for inspiration. In it I found an idea that proved to be the key to unlocking this problem. Sorry to leave you hanging but this dad needs some sleep üò¥.</p>

</div>
  <footer class="post-footer">



<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share SliceMap Rework - Part 1 on twitter"
        href="https://twitter.com/intent/tweet/?text=SliceMap%20Rework%20-%20Part%201&amp;url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-1%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SliceMap Rework - Part 1 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-1%2f&amp;title=SliceMap%20Rework%20-%20Part%201&amp;summary=SliceMap%20Rework%20-%20Part%201&amp;source=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SliceMap Rework - Part 1 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-1%2f&title=SliceMap%20Rework%20-%20Part%201">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SliceMap Rework - Part 1 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SliceMap Rework - Part 1 on whatsapp"
        href="https://api.whatsapp.com/send?text=SliceMap%20Rework%20-%20Part%201%20-%20https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SliceMap Rework - Part 1 on telegram"
        href="https://telegram.me/share/url?text=SliceMap%20Rework%20-%20Part%201&amp;url=https%3a%2f%2fmatthewcrews.com%2fblog%2f2021%2f08%2fslicemap-rework-part-1%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://matthewcrews.com">Matthew Crews</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    MathJax = {
    tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
    };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</body>

</html>
